{"pages":[],"posts":[{"title":"pygobject-tutorial-1","permalink":"http://sfork.coding.me/2016/11/08/pygobject-tutorial-1/","text":"基础这章将会介绍GTK+比较重要的几个方面 主循环和信号就像大部分GUI库一样，GTK+使用了一种事件驱动的编程模型。当用户什么都没做，GTK+让主循环处于就绪状态并等待用户的输入。如果用户做了一些动作，比如鼠标事件，主循环就会被唤醒，然后将这个事件传递给GTK+程序。 当部件收到一个事件，它们将会频繁的发出一个或者更多的信号，这些信号将会调用与之相绑定的函数。这样的函数通常被称作回调函数。当回调函数被调用时，你就可以进行一些操作了。比如说，你可能要弹出一个文件选择对话框当一个“打开”按钮被点击的之后。当回调函数执行完毕之后，GTK+将会返回到主循环然后等待用户再一次输入。 一个典型的例子：1handler_id = widget.connect('event',callback,data) 首先，widget是一个之前以及创建好的widget实例。接着，我们来看看事件，每个部件都有它自己的事件。举个例子，如果你有一个按钮，那么你往往希望绑定它的点击事件。这样只要按钮被点击，你就能收到它所触发的信号。然后，参数callback代表者需要调用的回调函数的名字，它包含者将要运行的代码，当特定的信号产生之后。最后，data参数包含着任意你想要传递的数据，这个参数是一个可选参数，如果不需要可以省略。该方法返回一个数值，标志着这个signal-callback对。当这个函数再也不会"},{"title":"JS DOM API分析","permalink":"http://sfork.coding.me/2016/11/02/dom-compatibility-note/","text":"Element.classList返回DOMTokenList,IE version&gt;=10不完全支持。 不支持classList.contains的第二个参数(force) add和remove方法不支持多参数 SVG,MathML结点没有classList属性 Node种类Node.nodeName Interface nodeName Comment #comment Document #document DocumentFragment #document-fragment Node的树遍历Node树遍历普遍要考虑空白文字结点。(whitespace textNode)。 Node.childNodes返回一个NodeList，表示该结点的所有子结点，包括文字结点和注释，该NodeList里面全部是object，并没有string。可以使用ParentNode.children来获得所有纯Element结点集合。 Node.firstChild返回结点的第一个子结点。可能是whitespace textNode。可以使用Element.firstElementChild来获得Element结点。 Node.lastChild返回结点的最后一个子结点。可能是whitespace textNode。可以使用Element.lastElementChild来获得Element结点。 Node.nextSibling返回下一个兄弟结点，可能是whitespace textNode。可以使用Element.nextElementSibling获得Element结点。 Node.previousSibling返回前一个兄弟结点，可能whitespace textNode。可以使用Element.previousElementSibling获得Element结点。 Node.innerText是一个非标准的属性，返回当前结点包括其子结点的所有文字。可以使用标准方法Node.textContent代替。 Node.textContentNode.parentElement返回当前Node的父Element元素，如果没有父Element元素，返回null。 Node.parentNode一个元素的parentNode可能是另一个元素、Document或者DocumentFragment。Document和DocumentFragment的parentNode是null，同样，一个刚刚创建的node，如果还没有加到dom树里面，它的parentNode同样是null。12//移除某element：ele.parentNode.removeChild(ele);"},{"title":"neutron源码分析","permalink":"http://sfork.coding.me/2016/10/28/neutron-code/","text":"消息总线Openstack各项目之间通过RESTful API进行通信；而项目内部不同服务进程则需要通过消息总线通信。关于消息总线的实现，包含在Openstack.oslo.messaging库中。 RPC远程过程调用，一个服务进程可以调用其他远程服务进程的方法，有两种方式： call 远程方法会被同步执行，调用者会阻塞直到取得返回结果。 cast 远程方法会被异步执行，调用者需要通过其他方式查询这次远程调用的结果。事件通知(Event Notification)服务可以把事件通知发到消息总线上，该消息总线上所有对此类事件感兴趣的服务进程，都可以获得次事件通知并进行处理。处理结果不会返回事件发送者。 AMQPAMQP是一个异步消息传递所使用的开放的应用层协议规范。包括导向、队列、路由、可靠性和安全性。不同的AMQP实现可以进行相互操作。所有消息都有一个routing key,所有Queue都有一个binding key。生产者将消息发送给Exchange,然后Exchange根据这两个key把消息送到相匹配的Queue中。不同类型的Exchange有不同的匹配算法。|类型|说明||—|—||Direct|binding key和routing key必须完全一样，不支持通配符||Topic|同Direct类型，但是支持通配符，”*”匹配单字，“#”匹配零个或多个单字，单字之间由“.”来分割||Fanout|忽略binding key和routing key，广播式路由| WSGIWSGI 是一个连接服务端和应用端的接口。WSGI把Web组件分为三部分： WSGI Server WSGI Middleware WSGI Application An Application must return an iterable object.123def application(environ,start_response): start_response('200 Ok',[('Content-Type','text/plain')]) yield 'Hello World\\n' environ:一个dict，包括CGI中定义的环境变量以及7个WSGI所定义的环境变量：wsgi.version,wsgi_input… start_response: 回调函数，要返回一个write(data)对象，用作兼容现有的特殊框架，一般返回None Paste.DeployPaste Deploy通过api-paste.ini配置Paste配置文件分为多个section，每个section以type:name的格式命名。（书上P99） WebOb对WSGI的封装，包含： webob.Request 对WSGI的environ的封装 webob.Response 对WSGI响应的封装 webob.exc 对HTTP错误代码的封装 Webob提供了webob.dec.wsgify的decorator，可以快速开发application12345678910111213# 继承自webob.Requestclass MyRequest(webob.Request): @property def is_local(self): return self.remote_addr == '127.0.0.1'@wsgify(RequestClass=MyRequest) def myfunc(req): if req.is_local: return Response('hi!') else: raise webob.exc.HTTPForbidden EventletOpenstack的协程模块 协程与线程类似，拥有独立的栈和局部变量，但是无法同时执行，(Compare To: Javascript callback) GreenThread123456import eventletdef my_func(param): # do something in coroutine return paramgt = eventlet.spawn(my_func,param)result = gt.wait() eventlet.spawn只是创建一个协程并不立即执行，直到主线程运行到gt.wait()时才开始进入调度序列。 Monkey Path实现协程需要使用Patch的方式对Python的网络相关的标准库进行改写，这个patch就叫monkey_patch。Monkey Patch是大部分使用Eventlet函数库之前需要进行的初始化工作1234# ceilometer/cmd/__init__.pyimport eventlet# patch socket,select,thread三个模块eventlet.monkey_patch(socket=True,select=True,thread=True) OsloOpenstack 通用库 Cliff构建命令行程序DEMO: https://github.com/openstack/cliff/tree/master/demoapp oslo.config解析命令行和配置文件中的配置选项（书上P111）1234567891011121314151617from oslo.config import cfgconf(sys.argv[1:],project=`xyz`) # 初始化，使得oslo.config能够正常解析配置文件和命令行选项rabbit_group = cfg.OptGroup(name='rabbit', title='RabbitMQ options')rabbit_host_opt = cfg.StrOpt('host', default='localhost', help='IP/hostname to listen on.'),rabbit_port_opt = cfg.PortOpt('port', default=5672, help='Port number to listen on.')def register_rabbit_opts(conf): conf.register_group(rabbit_group) # options can be registered under a group in either of these ways: conf.register_opt(rabbit_host_opt, group=rabbit_group) conf.register_opt(rabbit_port_opt, group='rabbit') 如果没有指定group，则选项默认放在[DEFAULT]组下123456789101112# glance-api.conf: [DEFAULT] bind_port = 9292 # ... [rabbit] host = localhost port = 5672 use_ssl = False userid = guest password = guest virtual_host = / 从命令行中设置conf，需要使用使用‘-’连接groupname和optionname1--rabbit-host localhost --rabbit-port 9999 oslo.dbSQLAlchemy数据库模型的抽象 oslo.i18n是对Python gettext的封装，主要用于字符串翻译和国际化 oslo.messagingOpenstack各项目使用RPC和事件通知的统一的接口。其中包括下面4个对象。 Transport传输层，主要实现RPC底层的通信，支持rabbit、qpid、zmq三种协议。可以通过URL来指定不同的transport的实现。1transport://user:pass@host1:port[,hostN:portN]/virtual_host Target封装了指定某一消息最终目的地的所有信息 Server即服务端，创建一个Server对象需要指定Transport、Target、endpoints(包含多组可被远程调用的方法，比如某一资源包含CUID四个操作） RPC Client即客户端，一个RPC Client可以调用RPC Server上的方法。 NotifierNotifier是一个用来发送通知消息的对象。格式如下：12345678&#123; message_id:six_text_type(uuid.uuid4()), #消息id号 publisher_id:&apos;computer.host1&apos;,#发送者id timestamp:timeutils.utcnow(),#时间戳 priority:&apos;WARN&apos;, # 通知优先级 event_type:&apos;compute.create_instance&apos;,#通知类型 payload:&#123;&apos;instance_id&apos;:12,...&#125; #通知内容&#125; Notifier Listener消息监听者，跟Server类似，可以暴露多个endpoint，每个endpoint中也可以包含多种方法，但是它们只是对应者不同的消息优先级。（P118）"},{"title":"Hexo折腾笔记（二）博客优化与定制","permalink":"http://sfork.coding.me/2015/02/25/hexo-lightum-enhance/","text":"首先我使用的是由zippera基于官方Light主题改进而来的Lightum主题,其他主题可能稍有出入。 ##速度优化参考之前的文章：静态页面优化。然后使用了hexo-qiniu-sync这个项目，将静态的图片以及css、js同步到了七牛云。（PS：主题模板中包含了两个不同版本的jquery，分别在head.ejs与after-footer.ejs中，随便删除一个。） 对于处于body区域的script、style的引用尽可能的加入data-no-instant属性，避免InstantClick重复加载。 ##给instantclick加载进度条加上阴影效果1234#instantclick-bar&#123;-webkit-box-shadow: 0 0 8px rgba(0, 0, 0, 0.56);box-shadow: 0 0 8px rgba(0, 0, 0, 0.56);&#125; ##加入Swiftype搜索去Swiftype官网申请代码，然后修改search.ejs文件为：12345&lt;div class=\"search\"&gt;&lt;form&gt;&lt;input type=\"search\" id=\"st-search-input\" placeholder=\"&lt;%= __('search') %&gt;\"&gt;&lt;/form&gt;&lt;/div&gt; 更具体的指导具体可以参考这篇文章：click here。 ##改进多说评论框 ###添加data-thread-key等属性123&lt;!-- 多说评论框 start --&gt;&lt;div class=\"ds-thread\" data-thread-key=\"&lt;%= page.path %&gt;\" data-title=\"&lt;%= page.title %&gt;\" data-url=\"&lt;%= page.permalink %&gt;\"&gt;&lt;/div&gt;&lt;!-- 多说评论框 end --&gt; ###美化多说评论框进入多说评论的管理后台，将下面代码粘贴到‘设置-&gt;自定义CSS’中。123456789101112#ds-reset .ds-avatar img&#123;width:54px;height:54px;border-radius:27px;-webkit-border-radius:27px;-moz-border-radius:27px;box-shadow:inset 0 -1px 0 #3333sf;-webkit-box-shadow:inset 0 -1px 0 #3333sf;-webkit-transition:0.4s;-webkit-transition:-webkit-transform 0.4s ease-out;transition:transform 0.4s ease-out;-moz-transition:-moz-transform 0.4s ease-out;&#125;#ds-reset .ds-avatar img:hover&#123;box-shadow:0 0 10px #fff;rgba(255,255,255,.6),inset 0 0 20px rgba(255,255,255,1);-webkit-box-shadow:0 0 10px #fff;rgba(255,255,255,.6),inset 0 0 20px rgba(255,255,255,1);transform:rotateZ(360deg);-webkit-transform:rotateZ(360deg);-moz-transform:rotateZ(360deg);&#125;p.ds-powered-by,#ds-sync-checkbox,.ds-sync label&#123;display:none!important;&#125;#ds-reset .ds-rounded-top&#123;-webkit-border-top-right-radius:0px;-webkit-border-top-left-radius:0px;border-top-right-radius:0px;border-top-left-radius:0px;&#125;#ds-thread #ds-reset .ds-textarea-wrapper&#123;background:#fff;border:0;margin-bottom:20px;padding-right:0px;&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea&#123;min-height:80px;border:1px solid #ccc;padding:10px;-webkit-appearance:none;border-radius:0;background-color:#FFFFFF;border-color:#cccccc;box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);color:rgba(0,0,0,0.75);-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-transition:border-color 0.15s linear,background 0.15s linear;-moz-transition:border-color 0.15s linear,background 0.15s linear;-ms-transition:border-color 0.15s linear,background 0.15s linear;-o-transition:border-color 0.15s linear,background 0.15s linear;transition:border-color 0.15s linear,background 0.15s linear;&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea:focus&#123;border-color:#999999;background:#fafafa;outline:none;&#125;#ds-thread #ds-reset .ds-post-options&#123;border-bottom-left-radius:0px;-webkit-border-bottom-left-radius:0px;border:none;background:none!important;&#125;#ds-thread #ds-reset .ds-post-button&#123;border-bottom-right-radius:0px;-webkit-border-bottom-right-radius:0px;&#125;#ds-reset .ds-textarea-wrapper textarea:focus&#123;border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);&#125;#ds-thread #ds-reset .ds-post-button&#123;background-image:none;text-shadow:none;border:none;font-weight:normal;line-height:normal;position:absolute;-webkit-appearance:button;-moz-appearance:button;background-color:#008CBA;border-color:#007095;color:#FFFFFF;transition:background-color 300ms ease-out;&#125;#ds-thread #ds-reset .ds-post-button:hover,#ds-thread #ds-reset .ds-post-button:focus&#123;background-color:#007095;color:#FFFFFF;&#125; ##加入多说最新评论修改’theme/lightum/_config.yml’文件，在widgets下面添加- recent_comments项。在主题文件的’theme/lightum/layout/_widget’目录中新建recent_comments.ejs文件，并放入如下代码：1234567891011&lt;div class=&quot;widget tag&quot;&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;%= __(&apos;recent_comments&apos;)&lt;/h3&gt;&lt;div class=&quot;entry&quot;&gt;&lt;!-- 多说最新评论 start --&gt; &lt;div class=&quot;ds-recent-comments&quot; data-num-items=&quot;5&quot; data-show-avatars=&quot;1&quot; data-show-time=&quot;1&quot; data-show-title=&quot;1&quot; data-show-admin=&quot;1&quot; data-excerpt-length=&quot;70&quot;&gt;&lt;/div&gt;&lt;!-- 多说最新评论 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;..........&lt;!-- 多说公共JS代码 end --&gt;&lt;/div&gt;&lt;/div&gt; 然后在’/languages/zh-CN.yml’文件添加翻译：recent_comments: 最新评论 最后，原来的评论样式不太符合lightum主题，可以在’/source/css/_partial’里建立一个recent_comment.styl文件：1234.ds-recent-comments li.ds-comment &amp;:first-child border-top none !important 然后在/theme/lightum/source/css/style中将之包括进来：@import &#39;_partial/recent_comments&#39; 多说的这个插件同样不兼容于instantclick。我们可以在这篇文章的基础上解决：click here: 将多说的公共JS放入head或加入’data-no-instant’属性放入body中，并删除recent.ejs与comment.ejs中重复的JS。 修改change事件中的代码为：123456if(typeof DUOSHUO !== &apos;undefined&apos;)&#123; //support 多说评论框if($(&quot;.ds-thread&quot;).length)&#123; DUOSHUO.EmbedThread($(&apos;.ds-thread&apos;)[0]);&#125;DUOSHUO.RecentComments($(&apos;.ds-recent-comments&apos;)[0]);&#125; 这样虽然能够解决问题，但是会显示方面又会出现点小问题。可以加入下面css修复：123span.caption&#123;display: none;&#125; 加入文章导航修改’/layout/_partical/article.ejs’文件1234567891011121314&lt;article class=\"&lt;%= item.layout %&gt;\"&gt; // ... &lt;div class=\"entry\"&gt; &lt;% if (item.excerpt &amp;&amp; index)&#123; %&gt; &lt;%- item.excerpt %&gt; &lt;% &#125; else &#123; %&gt; &lt;% if (!index)&#123; %&gt; // 插入文章导航 &lt;%- partial('toc') %&gt; &lt;% &#125; %&gt; &lt;%- item.content %&gt; &lt;% &#125; %&gt; &lt;/div&gt;&lt;/article&gt; 在’\\source\\css_partial\\article.styl’文件后添加：1234567891011121314151617181920.toc-article float right #toc background #eee margin 0 0 10px 20px padding 12px line-height 18px font-size 10px strong font-size 15px ol margin-top 5px margin-left 0 .toc padding 0 li list-style-type none .toc-child padding-left 20px 这样，我们就能在写文章的时候添加toc: true来启动文章导航功能。 ###扩展：浮动式导航实现当页面滑动到下方时将文章导航浮动到屏幕右侧。 在’\\layout_partial\\’里新建文件：float_nav.ejs1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div id=\"menu-nav\"&gt; &lt;div id=\"title-nav\"&gt;&lt;%= __('navigation') %&gt;&lt;div&gt;→&lt;/div&gt; &lt;/div&gt; &lt;div id=\"content-nav\"&gt; &lt;%- toc(item.content) %&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;(function($, scrollSpeed, hiddenSpeed, fadeSpeed) &#123; var T = $('#toc'); var M = $('#menu-nav'); var C = $('#content-nav'); var Tx = T.position().top; $(window).scroll(function() &#123; var top = $(this).scrollTop(); if (top &gt;= Tx + 300) &#123; M.stop().fadeIn(fadeSpeed); T.stop().fadeTo(fadeSpeed, 0); &#125; else &#123; M.stop().fadeOut(fadeSpeed); T.stop().fadeTo(fadeSpeed, 1); &#125; &#125;); $('.toc-link').click(function(e) &#123; //阻止默认跳转 e.preventDefault(); //定义滚动动画 var scrollTarget = $('#' + $(this).children('.toc-text').first().text()); $(\"html,body\").animate(&#123; scrollTop: scrollTarget.prev().offset().top &#125;, scrollSpeed); &#125;); C.click(function(e) &#123; e.stopPropagation(); &#125;); M.click(function() &#123; C.toggle(hiddenSpeed, 'linear', function() &#123; var T = $('#title-nav div'); T.text() == '←' ? T.text('→') : T.text('←'); &#125;); &#125;);&#125;)(jQuery, 500, 200, 100);&lt;/script&gt; 在’layout/_partial/article.ejs’中添加对其的引用：123&lt;% if(!index &amp;&amp; item.toc)&#123; %&gt; &lt;%- partial('float_nav') %&gt;&lt;% &#125; %&gt; 添加css样式：123456789101112131415161718192021222324252627282930313233343536373839navbcolor=rgba(100, 100, 100, 0.74)#menu-nav position fixed; display none; cursor pointer; z-index 150; right 0; top 20%; box-shadow 0 0 5px rgba(0, 0, 0, 0.15); color white; background navbcolor; #title-nav display inline-block; vertical-align middle; width: 30px; height: 100%; font-size: 16px; text-align: center; padding: 10px 0; #content-nav display inline-block; vertical-align middle; white-space:nowrap; border-left: 1px dashed #ccc; box-sizing border-box; padding 15px; line-height 18px; font-size 10px; li list-style-type none; width 100%; a display block; box-sizing border-box; color #FFFFFF; &amp;:hover background rgba(100, 100, 100, 1); .toc-child a padding-left 20px; ###添加”返回顶部”与上一节相似，在’layout/_widget/‘中添加totop.ejs文件：12345678910111213141516171819&lt;div id=\"to-top\"&gt;↑&lt;/div&gt;&lt;script&gt;(function($, scrollSpeed, fadeSpeed) &#123; var T = $('#to-top'); $(window).scroll(function() &#123; var top = $(this).scrollTop(); if (top &gt;= 300) &#123; T.stop().fadeIn(fadeSpeed); &#125; else &#123; T.stop().fadeOut(fadeSpeed); &#125; &#125;); T.click(function() &#123; $(\"html,body\").animate(&#123; scrollTop: 0 &#125;, scrollSpeed); &#125;);&#125;)(jQuery, 500, 200);&lt;/script&gt; 在’lightum/_config.yml’中启用该挂件：12widgets:- totop 添加css样式：12345678910111213141516#to-top background navbcolor; position fixed; display none; z-index 200; right 40px; bottom 10%; box-shadow 0 0 5px rgba(0, 0, 0, 0.15); font-size 14px; color white; padding 5px 15px; cursor pointer; font-size 12px; text-align center; &amp;:hover background rgba(100,100,100,1); ##参考 Hexo 主题修改:为博客实现更多功能 多说评论也玩圆角头像动画「自定义CSS:无压力小白级教程」 Hexo 优化与定制(二)"},{"title":"Hexo折腾笔记（一）博客加速以及解决instantclick的兼容问题","permalink":"http://sfork.coding.me/2015/02/25/hexo-speedup-instantclick/","text":"首先，Gitcafe的国内速度已经够快了，加不加速其实没多大区别,只不过是闲的蛋疼而已。Gitcafe无故page不更新，所以又换回了github。 Hexo加速Hexo加速可以有以下几个方面： 使用BootCDN并将图片等资源储存至七牛云。可以使用此项目click here。 使用hexo optimize压缩优化HTML、CSS、JS、Image资源。 使用InstantClick。 InstantClick是一款类似于Turbolinks的js库，利用pjax（pushState and Ajax)技术对网站进行优化，能够极大的提高访问速度。 解决InstantClick的兼容问题InstantClick效果明显，但是副作用也大。加入它之后，原来相处无碍的Fancybox、百度分享、百度统计、 mathJax、多说评论都挂了。下面是我的解决方法： ###FancyboxFancybox的修复首先要避面页面切换时jquery.fancybox.min.js文件的重复加载。可以将该js文件的引用放入head中或者加入data-no-instant属性。然后，因为instantclick在预加载时默认只替换body元素，所以在绑定fancybox的时候需要设置parent属性为body：123(function($)&#123; $('.fancybox').fancybox(&#123;parent:'body'&#125;);&#125;)(jQuery); 这样就应该可以了。 ###多说评论（以及最新评论、热评文章等）首先，多说的公共JS是不能放在加入data-no-instant属性的。因为不是网站所有页面都包含评论部分的。因此，我们需要将其裹入一层判断中来阻止其多次加载，提高网页的访问速度：123456789101112131415&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type=\"text/javascript\"&gt;if(typeof duoshuoQuery === 'undefined')&#123; var duoshuoQuery = &#123;short_name:\"你的域名\"&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)();&#125;&lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt; 然后，我们需要在页面预加载的change事件里对其进行重载：12345678910&lt;script data-no-instant&gt;InstantClick.on('change', function(isInitialLoad) &#123; if (isInitialLoad === false) &#123; if($(\".ds-thread\").length &amp;&amp; typeof DUOSHUO !== 'undefined')&#123; //support 多说评论框 DUOSHUO.EmbedThread($('.ds-thread')[0]); &#125; &#125;&#125;);InstantClick.init();&lt;/script&gt; 可以用同样的方式解决多说的热门文章、最新评论等插件的问题。DUOSHUO全部的重载函数有：&quot;EmbedThread&quot;, &quot;RecentComments&quot;, &quot;RecentVisitors&quot;, &quot;TopUsers&quot;, &quot;TopThreads&quot;, &quot;LoginWidget&quot;, &quot;ThreadCount&quot; ###百度统计、google统计、MathJax这三个可以参考这篇文章：click here。同样是在change事件里对他们进行重新加载。123456789101112InstantClick.on('change', function(isInitialLoad) &#123; if (isInitialLoad === false) &#123; if (typeof MathJax !== 'undefined') // support MathJax MathJax.Hub.Queue([\"Typeset\",MathJax.Hub]); if (typeof prettyPrint !== 'undefined') // support google code prettify prettyPrint(); if (typeof _hmt !== 'undefined') // support 百度统计 _hmt.push(['_trackPageview', location.pathname + location.search]); if (typeof ga !== 'undefined') // support google analytics ga('send', 'pageview', location.pathname + location.search); &#125;&#125;); ###百度分享百度分享可以用jiathis代替，其实国内的分享工具都差不多。 ##关于data-no-instant属性data-no-instant属性是用来避免instantclick在页面切换时对该元素重复加载。可以用在script、style标签中，也能放在a标签中，表示该链接将使用正常方式打开而不用instantclick加速。 data-no-intant无法阻止对div等元素的重新加载，因此无法实现像网易云音乐那样在切换页面的时候无间断的播放音乐等功能。不过曾有人contribute过类似的功能，但是作者没有接受：click here。 至此全部问题解决了，其他的问题可以参考下面几个链接： 整合 InstantClick 與 AddThis Hexo 静态博客加速 fancybox文档 InstantClick文档"},{"title":"Shadowsocks免费账号网址集","permalink":"http://sfork.coding.me/2015/02/24/shadowsocks-account/","text":"G+圈子很多这样的网站，大部分是由ss-panel这个开源项目建成。不知道他们是乐于分享还是另有目的。下面是列表： Shadow X(ss-panel作者) kuaishangSS pepsishadowsocks ChangZ ssserver 另外推荐Linux下ss GUI客户端：shadowsocks-qt5"},{"title":"ASP.NET MVC 4笔记（二）","permalink":"http://sfork.coding.me/2015/02/24/ASP-NET-MVC4note2/","text":"有Timestamp修饰的表在修改已有的记录是一定要将该字段复制，也就是说一定要在Edit网页里面添加一行：@Html.HiddenFor(model =&gt; model.RowVersion) WebSecurity.CreateAccount必须在Userprofile里面先创建账户。System.Diagnostics.Debug.WriteLine(&quot;OnAction:&quot; + controller + &quot;/&quot; + action); 转换string数组到int数组int[] HostsList = Array.ConvertAll&lt;string, int&gt;(Request[&quot;HostsId&quot;].Split(&apos;,&apos;), u =&gt; int.Parse(u));"},{"title":"ASP.NET MVC4笔记（一） 扩展Simplemembership","permalink":"http://sfork.coding.me/2015/02/24/ASP-NET-MVC4-note1-Simplemembership/","text":"1234567891011121314151617181920using System.Web.Mvc;namespace MvcClassManageSystem.ActionFilters&#123; public class LogStateFilterAttribute : ActionFilterAttribute &#123; public override void OnActionExecuting(ActionExecutingContext filterContext) &#123; base.OnActionExecuting(filterContext); //string controller = filterContext.RouteData.Values[&quot;controller&quot;].ToString(); //string action = filterContext.RouteData.Values[&quot;action&quot;].ToString(); //System.Diagnostics.Debug.WriteLine(&quot;OnAction:&quot; + controller + &quot;/&quot; + action); if (WebMatrix.WebData.WebSecurity.IsAuthenticated == true) &#123; filterContext.Result = new RedirectToRouteResult(new System.Web.Routing.RouteValueDictionary(new &#123; Controller = &quot;Home&quot;, action = &quot;Index&quot; &#125;)); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526public static class WebUtility &#123; private static SimpleMembershipProvider membership = (SimpleMembershipProvider)Membership.Provider; public static void CreateUserAndAccount(UserProfile userProfile, string Password) &#123; WebSecurity.CreateUserAndAccount(userProfile.UserName, Password, new &#123; //TO DO 数据库/模型更改之后别忘记修改此处！！！ ClassId = userProfile.ClassId, UserExtraInfo_Phone = userProfile.UserExtraInfo.Phone, UserExtraInfo_Gender = userProfile.UserExtraInfo.Gender, UserExtraInfo_BirthDay = userProfile.UserExtraInfo.BirthDay, UserExtraInfo_UserDesc = userProfile.UserExtraInfo.UserDesc &#125;); &#125; public static void DeleteUserAndAccount(string UserName) &#123; membership.DeleteAccount(UserName); Roles.RemoveUserFromRoles(UserName, Roles.GetRolesForUser(UserName)); membership.DeleteUser(UserName, true); &#125; public static void ResetPassword(string UserName, string NewPassword) &#123; WebSecurity.ResetPassword(WebSecurity.GeneratePasswordResetToken(UserName, 1), NewPassword); &#125; &#125; 123456789101112131415using System.Web.Mvc;namespace MvcClassManageSystem.Filters&#123; public class MyAuthorizeAttribute : AuthorizeAttribute &#123; protected override void HandleUnauthorizedRequest(AuthorizationContext filterContext) &#123; base.HandleUnauthorizedRequest(filterContext); if (filterContext.HttpContext.User.Identity.IsAuthenticated) &#123; filterContext.Result = new RedirectResult(&quot;/Account/AccessError&quot;); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System.Data.Entity;using System.Linq;using System.Web.Security;using WebMatrix.WebData;namespace MvcClassManageSystem.Models&#123; public class InitSecurityDb : DropCreateDatabaseAlways&lt;DBManager&gt; &#123; protected override void Seed(DBManager context) &#123; WebSecurity.InitializeDatabaseConnection(&quot;DefaultConnection&quot;, &quot;UserProfile&quot;, &quot;UserId&quot;, &quot;UserName&quot;, autoCreateTables: true); var roles = (SimpleRoleProvider)Roles.Provider; string[] RolesList = new string[] &#123; &quot;Admin&quot;, &quot;Teacher&quot;, &quot;Student&quot; &#125;; foreach (var item in RolesList) &#123; if (!roles.RoleExists(item)) &#123; roles.CreateRole(item); &#125; &#125; //设置初始班级 int ClassIndex = 0; using (var db = new DBManager()) &#123; var ret = db.ClassProfiles.SingleOrDefault(m =&gt; m.ClassName.CompareTo(&quot;未知班级&quot;) == 0); if (ret == null) &#123; ret = db.ClassProfiles.Add(new ClassProfile &#123; ClassName = &quot;未知班级&quot;, Desc = &quot;班级未知或无意义&quot; &#125;); db.SaveChanges(); &#125; ClassIndex = ret.ClassId; &#125; if (!WebSecurity.UserExists(&quot;管理员&quot;)) &#123; WebUtility.CreateUserAndAccount(new UserProfile() &#123; UserName = &quot;管理员&quot;, ClassId = ClassIndex, UserExtraInfo = new UserExtraInfo() &#123; Phone = &quot;18267912632&quot;, Gender = MvcClassManageSystem.Models.Gender.男, BirthDay = new System.DateTime(1993, 9, 28), UserDesc = &quot;本站的管理员！&quot; &#125; &#125;, &quot;admin&quot;); System.Web.Security.Roles.AddUserToRole(&quot;管理员&quot;, &quot;Admin&quot;); &#125; &#125; &#125;&#125; 1234567891011121314151617 protected void Application_Start() &#123; Database.SetInitializer&lt;DBManager&gt;(new InitSecurityDb()); DBManager db = new DBManager(); db.Database.Initialize(true); if (!WebSecurity.Initialized) &#123; WebSecurity.InitializeDatabaseConnection(&quot;DefaultConnection&quot;, &quot;UserProfile&quot;, &quot;UserId&quot;, &quot;UserName&quot;, autoCreateTables: true); &#125; AreaRegistration.RegisterAllAreas(); WebApiConfig.Register(GlobalConfiguration.Configuration); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); AuthConfig.RegisterAuth(); &#125;"},{"title":"再来晒晒我的KDE","permalink":"http://sfork.coding.me/2015/02/14/show-kde4-again/","text":"RT，我就这点出息，不过Arch上KDE4正在慢慢过渡到KDE5，这个桌面用不了多久就out of date了。 so sad…."},{"title":"KDE的Mac向折腾指南","permalink":"http://sfork.coding.me/2014/12/07/kde-to-mac/","text":"惯例，先上图： 首先，KDE的全局菜单可以参考我以前的文章《KDE4的配置参考》。 然后，Plasma的主题是AG-plasma，aurorae主题是Yoxydaze-light。这些可以去kde-look里找。 底部的dock是plank，主题是ArHU，在deviantART中找到的。另外，plank上的图标是受gtk主题控制的，所以装numix-circle是最好不过的。 我的apps文件可以在这里下载：click here ~/.config/plank/dock1/settings文件：12345678910111213141516171819202122232425262728293031323334#This file auto-generated by Plank.#2014-12-06T09:47:52+0000[PlankDockPreferences]#Whether to show only windows of the current workspace.CurrentWorkspaceOnly=false#The size of dock icons (in pixels).IconSize=42#If 0, the dock won&apos;t hide. If 1, the dock intelligently hides. If 2, the dock auto-hides. If 3, the dock dodges active maximized windows.HideMode=0#Time (in ms) to wait before unhiding the dock.UnhideDelay=0#The monitor number for the dock. Use -1 to keep on the primary monitor.Monitor=-1#List of *.dockitem files on this dock. DO NOT MODIFYDockItems=plank.dockitem;;google-chrome.dockitem;;dolphin.dockitem;;juk.dockitem;;eclipse.dockitem;;chrome-pjkebmlmkppdjcdcilfcjdkifljollfd-Default.dockitem;;kate.dockitem;;gwenview.dockitem;;wps-office-wps.dockitem;;konsole.dockitem;;sublime_text_3.dockitem;;love-wallpaper.dockitem;;ksysguard.dockitem;;virtualbox.dockitem#The position for the dock on the monitor. If 0, left. If 1, right. If 2, top. If 3, bottom.Position=3#The dock&apos;s position offset from center (in percent).Offset=0#The name of the dock&apos;s theme to use.Theme=ArHU#The alignment for the dock on the monitor&apos;s edge. If 0, panel-mode. If 1, left-aligned. If 2, right-aligned. If 3, centered.Alignment=3#The alignment of the items in this dock if panel-mode is used. If 1, left-aligned. If 2, right-aligned. If 3, centered.ItemsAlignment=3#Whether to prevent drag&apos;n&apos;drop actions and lock items on the dock.LockItems=false#Whether to use pressure-based revealing of the dock if the support is available.PressureReveal=false#Whether to show only pinned applications. Useful for running more then one dock.PinnedOnly=true#Whether to automatically pin an application if it seems useful to do.AutoPinning=true ~/.local/share/plank/themes/ArHU/中的dock.theme和hover.theme文件分别是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#This file auto-generated by Plank.#2014-12-06T06:22:37+0000[PlankDrawingTheme]#The roundness of the top corners.TopRoundness=6#The roundness of the bottom corners.BottomRoundness=0#The thickness (in pixels) of lines drawn.LineWidth=0#The color (RGBA) of the outer stroke.OuterStrokeColor=0;;0;;0;;0#The starting color (RGBA) of the fill gradient.FillStartColor=255;;255;;255;;150#The ending color (RGBA) of the fill gradient.FillEndColor=255;;255;;255;;150#The color (RGBA) of the inner stroke.InnerStrokeColor=255;;255;;255;;255[PlankDrawingDockTheme]#The padding on the left/right dock edges, in tenths of a percent of IconSize.HorizPadding=0#The padding on the top dock edge, in tenths of a percent of IconSize.TopPadding=1#The padding on the bottom dock edge, in tenths of a percent of IconSize.BottomPadding=1#The padding between items on the dock, in tenths of a percent of IconSize.ItemPadding=4#The size of item indicators, in tenths of a percent of IconSize.IndicatorSize=0#The size of the icon-shadow behind every item, in tenths of a percent of IconSize.IconShadowSize=0#The height (in percent of IconSize) to bounce an icon when the application sets urgent.UrgentBounceHeight=0.10000000000000001#The height (in percent of IconSize) to bounce an icon when launching an application.LaunchBounceHeight=0.10000000000000001#The opacity value (0 to 1) to fade the dock to when hiding it.FadeOpacity=0#The amount of time (in ms) for click animations.ClickTime=150#The amount of time (in ms) to bounce an urgent icon.UrgentBounceTime=300#The amount of time (in ms) to bounce an icon when launching an application.LaunchBounceTime=300#The amount of time (in ms) for active window indicator animations.ActiveTime=150#The amount of time (in ms) to slide icons into/out of the dock.SlideTime=150#The time (in ms) to fade the dock in/out on a hide (if FadeOpacity is &amp;lt; 1).FadeTime=100#The time (in ms) to slide the dock in/out on a hide (if FadeOpacity is 1).HideTime=100#The size of the urgent glow (shown when dock is hidden), in tenths of a percent of IconSize.GlowSize=30#The total time (in ms) to show the hidden-dock urgent glow.GlowTime=10000#The time (in ms) of each pulse of the hidden-dock urgent glow.GlowPulseTime=2000#The hue-shift (-180 to 180) of the urgent indicator color.UrgentHueShift=150#The time (in ms) to move an item to its new position.ItemMoveTime=150 123456789#This theme written by Perian. thexperian.deviantart.com[PlankDrawingTheme]TopRoundness=3LineWidth=0OuterStrokeColor=0;;0;;0;;0FillStartColor=0;;0;;0;;150FillEndColor=0;;0;;0;;150InnerStrokeColor=0;;0;;0;;0 以上是我折腾的结果，找主题也找了半天。大家如果有更好的主题与壁纸也拿来分享一下吧。"},{"title":"(转)慢慢的，就没有了，就像从未存在过","permalink":"http://sfork.coding.me/2014/11/28/man-man-de/","text":"几年以前，我曾经嘲笑过某科技界大佬。当时他说：也许90后、95后会慢慢不知道谷歌是什么网站。 那一年，这对于我来说简直就是世界上最好笑的笑话。谷歌，全世界最卓越的互联网公司，活在互联网的一代中国人，会不知道他们的网站？ 今天，我收回这句嘲笑。因为这件不可能的事，它慢慢变成了现实。 没有人再关注什么谷歌不谷歌。对他们来说，百度也蛮好用的，反正他们几乎没用过谷歌。没有谷歌又怎样？大家还是开心的刷微博，看微信，听歌，看娱乐节目。对于从来就不知道谷歌的人来说，少了谷歌又有什么影响？ 多年前，我们也是可以登陆Facebook的。其实这个网站和校内一样，也挺蠢的。可在上面你能看到老外们的生活，可以轻易的跟一万公里以外的人互相拜访，可以看到很多根本不会开到校内上的主页。你用汉语回复，下面给你聊起来的可能是香港仔，可能是台湾人。你用英语回复，说不定有比你英语用的更蹩脚的寂寞的北欧人来跟你搭讪。你感觉地球真的变成了地球村，你还没拉门走出去，别人就推门走了进来。 然后，它就没有了。起初，它的失踪激起了很大的声音，后来，声音就消失了。 多年前，我们也是可以登陆Twitter的。其实这个网站和微博一样，也不过是些信息流，刷上一整天，也不见得有什么用处。但至少，你可以以最快速度获取你想知道的任何新事，你会真正了解什么事情在全世界是流行的，而不是经过各种截图、翻译、转发，甚至曲解、断章取义、黑白颠倒的东西。你知道的是真相，赤裸裸的，也许有点太短的真相。但至少中间不会有无数人的加工与再加工，偏激、片面，就在这个过程中产生了，不管后来者有意还是无意。 然后，它就没有了。首先是它的本体没有了，然后它的模仿者也没有了，模仿者的模仿者也没有了。只剩一个模仿者的模仿者的模仿者，现在你每天能在上面看到无数广告。 多年前，我们也是可以登陆YouTube的。对于有的人来说，这个网站就是个大型优酷，当年有人信誓旦旦的说，没有YouTube，我们中国人会很快让优酷超过YouTube。可这么多年过去了，视频还是那么卡，内容还是那么垃圾，原创还是那么容易被盗窃，视频丰富度还是那么的可怜。在YouTube上，你能看到全世界最棒的手艺人，最逗乐的笑话，最天马行空的创意，最激荡人心的音乐，最美好的完美瞬间，可在优酷上，你想看一分钟视频，请先看半分钟广告。 哦，对了。Instagram，有些人可能感觉它和QQ空间也差不多。可我在上面关注了六百多个摄影师，它们都是顶好顶好的影像记录者，每天看他们的作品，我感觉到很幸福，那种即使没有到那里去，也身临其境的幸福。我还在上面认识了一个日本的爱自拍的帅小伙，一个爱喝酒的韩国大叔，一个十年前到过中国今天会在每张我发的紫禁城照片下点赞的美国大爷，一个美丽无比的俄罗斯妹子，我和他们基本上都难以交流，语言是很大的障碍，但几个简单的单词，心意也就到了，这种感觉，有时候比多年老友相聚还兴奋。因为这是人类不同族群自由交流互相沟通的过程，这种过程很神奇，真的很神奇。 可现在，它没有了，它之所以没有就因为在某个特定的时间你在搜索特定的词汇时，会搜出来特定的照片。虽然这么搜的人并不多，虽然看到的人也不会大惊小怪，也不会觉得天黑了，天亮了，天要塌了，天要变了。可它就是没了，Instagram，就这么没了。谷歌也是这么没的，Twitter也是这么没的，Facebook也是这么没的。不知道是什么人，在什么场合，说了什么话，下了什么决定。就要有超过十亿人像陷于哥谭市的孤岛里一样，看着一座又一座桥梁被炸掉，又被炸掉，又被炸掉，然后，就什么都没了。 我时常觉得悲哀，真的好悲哀，一个我根本不认识也不知道是谁的人，也许是一个群体，在不断抢走我身边的东西，而我却无能为力。我抱怨一声，他听不到，任何人都听不到。我怒吼一句，身边的大多数人却像看疯子一样的看着我。我哀嚎一声，这声音被阻碍在黑黑的幕墙以里。我发出尖锐的嘶吼，这声音传不了多远，就和我那被抢走的东西一样，消失了，不见了，就像从来没存在过一样。 对于本来就没存在过的东西，有谁又会觉得在意呢？那些本来拥有又被掠夺的人的哀愁，后来的人又怎么懂呢？我曾经是拥有一切的，我曾经是拥有世界的，我站在这片土地上，呼吸的是自由的空气，饮下的是自由的琼浆玉液。就在长的无法计数的时间里，我自由生命的一部分又一部分就这么被杀死了，突然就杀死了。可我还始终觉得，它们还奄奄一息的活着，就像它们是慢慢的死去的一样。 可它们终归是死了，而且随着它们的死，愈来愈多的事情慢慢的发生了，很慢很慢，几乎不被人察觉，可还是发生了。 没有谷歌，我可以用百度呀。可某些结果被越挪越后，越挪越后，最后就不见了。就像本来就不该搜出这个结果一样。 没有Facebook，我可以用校内呀。可你想发只有在Facebook上能发的文章，很快在校内上就失踪了。接着，校内变成了人人，话题变成了人人都关心的话题。大家都在抢着看星座、明星、八卦、娱乐。没有人会关心什么消失了，反正它们本来也没多少存在感。 没有YouTube，我可以用优酷呀。可你却经常只能在优酷上看到抄袭别人的作品，而且还不署名，而且还洋洋得意，而且还自我陶醉，就好像那个idea本来属于他自己一样。你看了还要惊呼，他是如此的有创意！好一个抄袭的创意，可你却不知道，因为你不知道这个世界上有个网站叫YouTube。 没有Twitter，我还可以用微博呀。可你想知道最近发生了什么，你搜的越勤快，越能看到越明显的“根据相关法律法规，相关搜索结果不予显示”。时间长了，你想，反正知道了也没什么用，不如不看了。 慢慢的，一扇又一扇的门关上了。今天你打开世界上最大的博客网站，发现它没了。明天你一看，世界上最好的设计师分享网站没了，一开始是刷新的很慢很慢，后来它就没了。过两天再一看，平常每天都会读两篇文章的媒体网站没了，那里的文章缤纷多彩，最后都变成了该页无法显示几个字。再过几个月，大学的网站不让上了，摄影师的网站不让上了，就连百度日本这种自家网站，也没了。 接着，漫画看不了了，接着，动画看不成了。接着，美剧英剧失踪了。下载美剧英剧的网站又又又失踪了。尊重正版，保护权益，行吧，然后字幕网站也没了。 游戏没了，你习惯性登陆的游戏网站，发现下载栏正在整治中。论坛关了，天天都在看的论坛，突然接到相关部门的电话，因为“报备问题”不让办了。个人网站，私人博客，对不起，说没就没有，你在上面存了多少多年辛勤耕耘的东西都没用。 你关注的人，有一天你登陆微博，发现他怎么好久都没说话了，然后你搜索了一下，发现他的账号不存在了，而且你搜他的名字，他的名字未予显示。 一盏一盏的灯，灭了。四面八方的光源，消失了。我们生活的五光十色的世界，变成了一片黑色。 天黑了，那么睡觉吧，但愿长醉不复醒。 最后，我们变成了一群做梦的人，这个梦的名字，叫根据相关法律法规，相关搜索结果不予显示梦。 作者：小海，来源：豆瓣网，原文已被和谐"},{"title":"ZOJ month contest D.Determinant and Matrix","permalink":"http://sfork.coding.me/2014/11/07/zoj-month-contest-d-determinant-and-matrix/","text":"Time Limit: 2 Seconds Memory Limit: 65536 KB ##DescriptionRecently, LBH is learning the curse linear algebra. Thus he is very interested in matrix and determinant now. In order to practice his ability of solving the problem of linear algebra, he just invent some problems by himself. Once the problems was create, he would solve it immediately. However, he meet a problem that was so hard that he couldn’t work out even though racked his brains. The problem was described as follow: To a integer martix Mnn(aij), we define two function add(Mnn(aij))=Mnn(aij + 1) and sub(Mnn(aij))=Mnn(aij - 1) which were exactly like this: According to the martix Mnn(aij), we can permutate it and get a full permutation set Perm(Mnn(aij)) = {Mnn(aIiJj)| I and J is a permutation of 1..n }, (Perm(M) is a set, each matrix in Perm(M) is unique). For example: The problem is to get the result of a fomula about an integer matrix Mnn: in which the det(M) meaned to cacluate the determinant of M. InputThere are several test cases. The first line contains an integer T(T ≤ 100) . Then T test cases follow. In each test case, the first line contains one integer n(0&lt; n≤ 10). The number means the giving matrix’s size is n×n Then there are n lines followed, each line contains n integers aij(-10≤ aij≤ 10), in the position row i, colum j, it represents the number aij. OutputFor each test case, since the result may be very large, output one line with the result modulo 230. Sample Input1234121 11 2 Sample Output12 Author: LIN, BinghuiSource: ZOJ Monthly, August 2014 这道题全场现场只A了一个人。今天我们比赛的时候我A了，挺爽的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.util.Scanner;import java.math.*;public class Main &#123; static long fact[]=new long[15]; static long kind; static int A[][]=new int[10][10]; static final BigInteger MOD=BigInteger.valueOf(1&amp;lt;&amp;lt;30); static void getKind(int n)&#123; boolean mark[]=new boolean[10]; for(int i,j,k,r=0;r&amp;lt;2;r++)&#123; for (i = 0; i &amp;lt; n; ++ i) mark[i] = false; for (i = 0; i &amp;lt; n; ++ i) &#123; if (mark[i]) continue; int cnt = 0; for (j = i; j &amp;lt; n; ++ j) &#123; for (k = 0; k &amp;lt; n; ++ k) &#123; if (r==1&amp;amp;&amp;amp;A[k][i] != A[k][j])break; if(r==0&amp;amp;&amp;amp;A[i][k] != A[j][k])break; &#125; if (k == n) &#123; ++ cnt; mark[j] = true; &#125; &#125; kind /= fact[cnt]; &#125; &#125; &#125; public static void main(String[] args)&#123; Scanner cin=new Scanner(System.in); int n,T=cin.nextInt(); fact[0]=1; for(int i=1;i&amp;lt;=10;i++)fact[i]=fact[i-1]*i; while(T--&amp;gt;0)&#123; n=cin.nextInt(); for(int i=0;i&amp;lt;n;i++)&#123; for(int j=0;j&amp;lt;n;j++)&#123; A[i][j]=cin.nextInt(); &#125; &#125; long res=0; Matrix matrix=new Matrix(n); kind=fact[n]*fact[n]; getKind(n); if(kind%2==1)&#123; matrix.valueOf(A, 0); res=res ^(matrix.Det().mod(MOD).longValue()); &#125; matrix.valueOf(A, 1); res=res^(matrix.Det().mod(MOD).longValue()); matrix.valueOf(A, -1); res=res^(matrix.Det().mod(MOD).longValue()); System.out.println(res); &#125; cin.close(); &#125;&#125;class Matrix&#123; BigInteger M[][]=new BigInteger[10][10]; BigInteger ZERO,ONE; int n; Matrix(int n)&#123; this.n=n; ZERO=BigInteger.ZERO; ONE=BigInteger.ONE; &#125; void valueOf(int A[][],int d)&#123; for(int i=0;i&amp;lt;n;i++)&#123; for(int j=0;j&amp;lt;n;j++)&#123; M[i][j]=BigInteger.valueOf(A[i][j]+d); &#125; &#125; &#125; BigInteger Det()&#123; BigInteger tmp, res = ONE, div = ONE; int i, j, k; for (i = 0; i &amp;lt; n; ++ i) &#123; for (j = i; j &amp;lt; n; ++ j) &#123; if (!M[j][i].equals(ZERO)) break; &#125; if (j == n) return ZERO; if (j != i) &#123; //res = res.negate(); for (k = 0; k &amp;lt; n; ++ k) &#123; tmp = M[j][k]; M[j][k] = M[i][k]; M[i][k] = tmp; &#125; &#125; res = res.multiply(M[i][i]); for (j = i + 1; j &amp;lt; n; ++ j) &#123; if (M[j][i].equals(ZERO)) continue; div = div.multiply(M[i][i]); for (k = i + 1; k &amp;lt; n; ++ k) &#123; M[j][k] = M[j][k].multiply(M[i][i]).subtract(M[i][k].multiply(M[j][i])); &#125; &#125; &#125; res = res.divide(div); if (res.compareTo(ZERO) &amp;lt; 0) res = res.negate(); return res; &#125;&#125;"},{"title":"FFT求快速卷积的思考","permalink":"http://sfork.coding.me/2014/11/06/fft-thoughts/","text":"离散型卷积的定义是：$$y(n)=\\sum_{m=0}^{n} x(m)h(n-m)$$ 注意，h函数是反转的。 在Chipher Messages一题中，b串需要反转再与a串匹配。 比如说： a串： 110110110，则： b`串：1011&lt;——这里才是原来b串的头。但是向上对应到a串时，已经是m-1这个位置了。所以说，小于m-1的卷积是没有意义的。 于是，base=m。整体匹配。 同样的，比如杭电1402用FFT求A×B那一题。 可以把A串看成卷积中的x函数，而把B串的每一个字符看成h函数。那么卷积就可以看成是一个模拟乘法的过程。 因为h函数是要求逆序的，但是此时的h函数只有一个字符所以反转操作无意义。这时候的base=1。单个匹配。 估计FFT就这两种情况了。因为如果1&lt;base&lt;m，那么就应该直接将b串分解成若干base长度的串了。"},{"title":"baylor 6622 Absurdistan Roads（ NWERC Contest）","permalink":"http://sfork.coding.me/2014/11/06/baylor6622-absurdistan-roads/","text":"原题pdf：click here ##DescriptionThe people of Absurdistan discovered how to build roads only last year. After the discovery, every citydecided to build their own road connecting their city with another city. Each newly built road can beused in both directions. Absurdistan is full of surprising coincidences. It took all N cities precisely one year to build theirroads. And even more surprisingly, in the end it was possible to travel from every city to every othercity using the newly built roads. You bought a tourist guide which does not have a map of the country with the new roads. It onlycontains a huge table with the shortest distances between all pairs of cities using the newly built roads. You would like to know between which pairs of cities there are roads and how long they are, becauseyou want to reconstruct the map of the N newly built roads from the table of shortest distances. You get a table of shortest distances between all pairs of cities in Absurdistan using the N roadsbuilt last year. From this table, you must reconstruct the road network of Absurdistan. There mightbe multiple road networks with N roads with that same table of shortest distances, but you are happywith any one of those networks. ##InputFor each test case: • A line containing an integer N (2 ≤ N ≤ 2000) — the number of cities and roads. • N lines with N numbers each. The j-th number of the i-th line is the shortest distance from city i to city j. • All distances between two distinct cities will be positive and at most 1 000 000. Thedistance from i to i will always be 0 and the distance from i to j will be the same as the distancefrom j to i. ##OutputFor each test case: • Print N lines with three integers ‘a b c’ denoting that there is a road between cities 1 ≤ a ≤ Nand 1 ≤ b ≤ N of length 1 ≤ c ≤ 1000000, where a ̸= b. If there are multiple solutions, you canprint any one and you can print the roads in any order. At least one solution is guaranteed toexist. • Print a blank line between every two test cases. ##Sample Input40 1 2 11 0 2 12 2 0 11 1 1 040 1 1 11 0 2 21 2 0 21 2 2 030 4 14 0 31 3 0 ##Sample Output2 1 14 1 14 2 14 3 12 1 13 1 14 1 12 1 13 1 12 1 43 2 3 NWERC 题目还挺简单的。题意就是一个N个顶点，N条边的无向图。告诉你两两点之间的最短路。让你重构这个图。(随意输出任意一张满足以上条件的图）这题的突破口就是N条边。要想想如果只有N-1条边，那么这个图就是一个树了。所以，我们可以先构造最小生成树，再来考虑最后一条边。可以先将构造好的树求一遍floyd，然后再跟题目的最短路相比较，如果两点u,v求出的最短路w`与题目给的最短路w不一致（可以断言：w`&gt;w），那么就将w作为最后一条边的边长加在u，v之间即可。这样的边可能会找到很多，事实上只需要加上任意一条就使所有的w`都等于w了。需要注意的是，可能整个树就已经满足题目了。这样的话，最后一条边只需要重复任意一条树边就好了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2010;const int inf = 1 &lt;&lt; 25;int p[N];int ufind(int x) &#123; return x == p[x] ? x : p[x] = ufind(p[x]);&#125;bool Union(int x, int y) &#123; int fx = ufind(x); int fy = ufind(y); if (fx == fy) return false; p[fx] = fy; return true;&#125;int n;struct Edge &#123; int u, v, w; Edge(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) &#123; &#125; bool operator&lt;(const Edge&amp; othr) const &#123; return w &lt; othr.w; &#125;&#125;;vector&lt;Edge&gt; vt;vector&lt;Edge&gt; res;int f[N][N];int main() &#123; bool first = true; while (~scanf(\"%d\", &amp;n)) &#123; vt.clear(); res.clear(); if (!first) printf(\"\\n\"); else first = false; for (int i = 1; i &lt;= n; i++) &#123; for (int x, j = 1; j &lt;= n; j++) &#123; scanf(\"%d\", &amp;x); if (j &gt; i) vt.push_back(Edge(i, j, x)); &#125; &#125; for (int i = 0; i &lt;= n; i++) p[i] = i; sort(vt.begin(), vt.end()); for(int i=1;i&lt;=n;i++) fill(f[i]+1,f[i]+1+n,inf); for (int cnt = 0, i = 0; i &lt; (int) vt.size(); i++) &#123; if (Union(vt[i].u, vt[i].v)) &#123; f[vt[i].u][vt[i].v] = vt[i].w; f[vt[i].v][vt[i].u] = vt[i].w; cnt++; res.push_back(Edge(vt[i].u, vt[i].v, vt[i].w)); if (cnt &gt;= n - 1) break; &#125; &#125; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (f[i][k] == inf) break; if (f[i][j] &gt; f[i][k] + f[k][j]) &#123; f[i][j] = f[i][k] + f[k][j]; &#125; &#125; &#125; &#125; int flag = true; for (int i = 0; i &lt; (int) vt.size(); i++) &#123; Edge now = vt[i]; if (f[now.u][now.v] != now.w) &#123; res.push_back(Edge(now.u, now.v, now.w)); flag = false; break; &#125; &#125; if (flag) res.push_back(res.back()); for (int i = 0; i &lt; (int) res.size(); i++) &#123; printf(\"%d %d %d\\n\", res[i].u, res[i].v, res[i].w); &#125; &#125;&#125;"},{"title":"Timus 1996 Cipher Message 3 KMP+FFT求卷积","permalink":"http://sfork.coding.me/2014/11/05/timus-1996-cipher-message-3-kmpfft/","text":"题目链接：click here ##descriptionEmperor Palpatine has been ruling the Empire for 25 years and Darth Vader has been the head of the Empire Armed Forces. However, the Rebel movement is strong like it never used to be. One of the rebel leaders, Princess Leia from Alderaan, managed to get hold of secret blueprints of the Death Star, the imperial war station. The Princess was going to deliver the station plan to the secret base for further analysis and searching for vulnerable spots. But her ship was attacked by the space destroyer “Devastator” headed by Darth Vader. At the last moment Princess Leia managed to send her findings to one of the closest planet called Tatooine with her droid R2-D2. Quite conveniently, an old friend of her father Obi-Wan Kenobi lives on that planet. R2-D2 realizes the importance of his mission. He is going to encrypt the information so that the wrong people won’t get it.The memory of R2-D2 has many files with images. First he wanted to use a well-known encrypting algorithm. The point of the method is to replace the least significant bits of the image with the encrypted message bits. The difference is practically unnoticeable on the picture, so one won’t suspect that it contains a hidden message. But then R2-D2 decided that this method is quite well-known and the information won’t be protected enough. He decided to change the least significant bits of the image so that the secret information was a continuous sequence of the bytes of the image file. Help the droid determine if it is possible. And if it is, find the minimum number of bits to alter. InputThe first line of the input contains integers n and m (1 ≤ n, m ≤ 250 000) — the sizes of the image file and of the file with the secret information in bytes. On the second line the content of the file with an image is given and the third line contains the secret information. The files are given as a sequence of space-separated bytes. Each byte is written as a sequence of eight bits in the order from the most to the least significant bit. OutputPrint “No”, if it is impossible to encrypt information in this image. Otherwise, print in the first line “Yes”, and in the second line — the number of bits to alter and the number of the byte in the file with the image, starting from which the secret information will be recorded. If there are multiple possible variants, print the one where the secret information is written closer to the beginning of the image file. Samples input output 3 2 11110001 11110001 1111000011110000 11110000 Yes1 2 input output 3 111110000 11110001 1111000011110000 Yes0 1 Problem Author: Denis Dublennykh (prepared by Oleg Dolgorukov) 题目老长难懂，其实就是给你一个n byte的01A串，m byte的01B串.其中A串中每一byte的最后一个bit是可以修改的，问至少修改多少次A串能使B使A的子串。输出修改次数与最小的起始匹配位置。 首先将A串每byte取前7位（代码中的a数组）与B串每byte取前7位（代码中的b数组）用KMP匹配，因为前7位不能改，所以如果没有一处匹配就直接输出No了。 然后将A串每byte取后1位（代码中的ax数组）与B串每byte取后一位（代码中的bx数组）求hamming距离。 如何求ax与bx的hamming距离呢？ 可以巧妙的ax作为卷积中的f函数，bx的逆向数组bx`作为卷积中的g函数。两者求卷积。这样就成了：$$c[i + m - 1] = ax[i + 0] bx`[m - 0 - 1] + ax[i + 1] bx`[m - 1 - 1] + …… ax[i + j] bx`[m - j - 1] + …… ax[i + m - 1] bx`[m - (m - 1) - 1]$$ 可以看出，如果ax , bx中同为1,乘积为1,否则为0,这样就能统计出了有多少位同为1了。 如果将ax,bx数组中的01取反，再进行上述操作，那么救能统计出有多少位同为0了。两者相加就是全部相同的有多少，用总字符数m减去它，就能求出hamming距离了！ 卷积复杂度为O(nlg(n))而暴力算法的复杂度为O(n×m)，真是太神奇了！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161using namespace std;const int N = 250005;int n, m;const double pi = acos(-1.0);// Complex z = a + b * istruct Complex &#123; double x, y; Complex(double x = 0.0, double y = 0.0) : x(x), y(y) &#123; &#125; Complex operator +(const Complex &amp;amp;c) const &#123; return Complex(x + c.x, y + c.y); &#125; Complex operator -(const Complex &amp;amp;c) const &#123; return Complex(x - c.x, y - c.y); &#125; Complex operator *(const Complex &amp;amp;c) const &#123; return Complex(x * c.x - y * c.y, x * c.y + y * c.x); &#125;&#125;;int a[N], b[N], ax[N], bx[N];char buf[8];/* * kmpNext[]的意思:next'[i]=next[next[...[next[i]]]] (直到next'[i]&amp;lt;0或者 x[next'[i]]!=x[i]) * 这样的预处理可以快一些 */void preKMP(int x[], int m, int kmpNext[]) &#123; int i, j; j = kmpNext[0] = -1; i = 0; while (i &amp;lt; m) &#123; while (-1 != j &amp;amp;&amp;amp; x[i] != x[j]) j = kmpNext[j]; if (x[++i] == x[++j]) kmpNext[i] = kmpNext[j]; else kmpNext[i] = j; &#125;&#125;/* * 返回x在y中出现的次数,可以重叠 */int next[N];vector pos;void KMP_Count(int x[], int m, int y[], int n) &#123; //x是模式串,y是主串 int i, j; pos.clear(); preKMP(x, m, next); i = j = 0; while (i &amp;lt; n) &#123; while (-1 != j &amp;amp;&amp;amp; y[i] != x[j]) j = next[j]; i++; j++; if (j &amp;gt;= m) &#123; pos.push_back(i - m); j = next[j]; &#125; &#125;&#125;//len = 2 ^ kinline void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &amp;lt; len - 1; i++) &#123; if (i &amp;lt; j) swap(y[i], y[j]); int k = len / 2; while (j &amp;gt;= k) &#123; j -= k; k /= 2; &#125; if (j &amp;lt; k) j += k; &#125;&#125;// FFT// len = 2 ^ k// on = 1 DFT on = -1 IDFTinline void FFT(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &amp;lt;= len; h &amp;lt;&amp;lt;= 1) &#123; Complex wn(cos(-on * 2 * pi / h), sin(-on * 2 * pi / h)); for (int j = 0; j &amp;lt; len; j += h) &#123; Complex w(1, 0); for (int k = j; k &amp;lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t; y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) &#123; for (int i = 0; i &amp;lt; len; i++) &#123; y[i].x /= len; &#125; &#125;&#125;//FFT求卷积,a数组长度n，b数组长度mint res[N];Complex x1[N &amp;lt;&amp;lt; 2], x2[N &amp;lt;&amp;lt; 2]; //FFT开4倍void Convolution(int a[], int b[]) &#123; int len = max(n, m); int l = 1; while (l &amp;lt; len * 2) l &amp;lt;&amp;lt;= 1; for (int i = 0; i &amp;lt; l; i++) x1[i] = Complex(i &amp;lt; n ? a[i] : 0, 0); for (int i = 0; i &amp;lt; l; i++) x2[i] = Complex(i &amp;lt; m ? b[i] : 0, 0); //DFT FFT(x1, l, 1); FFT(x2, l, 1); for (int i = 0; i &amp;lt; l; i++) x1[i] = x1[i] * x2[i]; //IDFT FFT(x1, l, -1); //based on m int base = m ; for (int i = 0; i &amp;lt;= n - base; i++) &#123; res[i] += (int) (x1[i + base - 1].x + 0.5); &#125;&#125;int main() &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;m)) &#123; for (int i = 0; i &amp;lt; n; i++) &#123; a[i] = 0; scanf(\"%s\", buf); for (int j = 0; j &amp;lt; 7; j++) &#123; a[i] = a[i] &amp;lt;&amp;lt; 1 | (buf[j] - '0'); &#125; ax[i] = buf[7] - '0'; &#125; for (int i = 0; i &amp;lt; m; i++) &#123; b[i] = 0; scanf(\"%s\", buf); for (int j = 0; j &amp;lt; 7; j++) &#123; b[i] = b[i] &amp;lt;&amp;lt; 1 | (buf[j] - '0'); &#125; bx[i] = buf[7] - '0'; &#125; KMP_Count(b, m, a, n); if (pos.size() == 0) puts(\"No\"); else &#123; reverse(bx, bx + m); memset(res, 0, sizeof(res)); puts(\"Yes\"); Convolution(ax, bx); for (int i = 0; i &amp;lt; n; i++) ax[i] ^= 1; for (int i = 0; i &amp;lt; m; i++) bx[i] ^= 1; Convolution(ax, bx); int ans = m, idx = 0; for (int i = 0; i &amp;lt; (int) pos.size(); i++) &#123; if (m - res[pos[i]] &amp;lt; ans) &#123; ans = m - res[pos[i]]; idx = pos[i] + 1; &#125; &#125; printf(\"%d %d\\n\", ans, idx); &#125; &#125;&#125;"},{"title":"（转）关于卷积的一个血腥的讲解，看完给跪了","permalink":"http://sfork.coding.me/2014/11/05/intro-of-fft/","text":"比如说你的老板命令你干活，你却到楼下打台球去了，后来被老板发现，他非常气愤，扇了你一巴掌（注意，这就是输入信号，脉冲），于是你的脸上会渐渐地（贱贱地）鼓起来一个包，你的脸就是一个系统，而鼓起来的包就是你的脸对巴掌的响应，好，这样就和信号系统建立起来意义对应的联系。下面还需要一些假设来保证论证的严谨：假定你的脸是线性时不变系统，也就是说，无论什么时候老板打你一巴掌，打在你脸的同一位置（这似乎要求你的脸足够光滑，如果你说你长了很多青春痘，甚至整个脸皮处处连续处处不可导，那难度太大了，我就无话可说了哈哈），你的脸上总是会在相同的时间间隔内鼓起来一个相同高度的包来，并且假定以鼓起来的包的大小作为系统输出。好了，那么，下面可以进入核心内容——卷积了！如果你每天都到地下去打台球，那么老板每天都要扇你一巴掌，不过当老板打你一巴掌后，你5分钟就消肿了，所以时间长了，你甚至就适应这种生活了……如果有一天，老板忍无可忍，以0.5秒的间隔开始不间断的扇你的过程，这样问题就来了，第一次扇你鼓起来的包还没消肿，第二个巴掌就来了，你脸上的包就可能鼓起来两倍高，老板不断扇你，脉冲不断作用在你脸上，效果不断叠加了，这样这些效果就可以求和了，结果就是你脸上的包的高度随时间变化的一个函数了（注意理解）；如果老板再狠一点，频率越来越高，以至于你都辨别不清时间间隔了，那么，求和就变成积分了。可以这样理解，在这个过程中的某一固定的时刻，你的脸上的包的鼓起程度和什么有关呢？和之前每次打你都有关！但是各次的贡献是不一样的，越早打的巴掌，贡献越小，所以这就是说，某一时刻的输出是之前很多次输入乘以各自的衰减系数之后的叠加而形成某一点的输出，然后再把不同时刻的输出点放在一起，形成一个函数，这就是卷积，卷积之后的函数就是你脸上的包的大小随时间变化的函数。本来你的包几分钟就可以消肿，可是如果连续打，几个小时也消不了肿了，这难道不是一种平滑过程么？反映到剑桥大学的公式上，f(a)就是第a个巴掌，g(x-a)就是第a个巴掌在x时刻的作用程度，乘起来再叠加就ok了，大家说是不是这个道理呢？我想这个例子已经非常形象了，你对卷积有了更加具体深刻的了解了吗？ 转自GSDzone论坛"},{"title":"KDE4的配置参考","permalink":"http://sfork.coding.me/2014/10/31/kde4-config/","text":"西北工大回来后,时间又充裕了,所以又开始了折腾KDE。 话说KDE的渲染阴影等效果非常接近MacBook。先放几张图： 下面说一下，我的配置过程： 发行版：我的发行版是Arch，没有Arch强大的AUR，很多桌面的配件很难装上。 主题：我的plasma主题是Helium与dynamo主题混合而成。标题栏主题是Qtcurve，图标主题是dynamo与flattr混合而成，鼠标主题是Breeze。应用程序主题是Qtcurve，配色是Breeze。这些都可以到这里下载。先安装qtcurve再将下载下来的文件解压并覆盖～/.kde4/share/即可。注意，Qtcurve的配置方案是Breeze，并且在窗口管理器中设置边框大小是无侧边框。 全局菜单：全局菜单可以先加archlinuxcn源，然后依次用yaourt安装appmenu-qt,appmenu-qt5,appmenu-gtk,kdeplasma-applets-menubar。完成之后在面板上添加刚安装的部件再打开“系统设置&gt;应用程序外观&gt;风格”然后选择微调标签，修改“菜单栏风格”为“仅导出”就能有全局菜单了。 最大化隐藏菜单栏：最大化隐藏菜单栏可以直接在qtCurve中配置，依然在“窗口管理器”中，勾选“最大化窗口无边框”复选框即可。 最大化上面板显示窗口控制按钮：（最后一张图鼠标所指的地方）在AUR中安装kdeplasma-applets-kwin-button-improved，然后在面板上重复三次添加这个部件，分别设置为最小化（iconify），最大化/回复（maximize/restore）和关闭（close）就行了。"},{"title":"ACM International Collegiate Programming Contest Asia Regional Contest, Tokyo Problem D Space Golf","permalink":"http://sfork.coding.me/2014/10/19/acm-international-collegiate-programming-contest-asia-regional-contest-tokyo-problem-d-space-golf/","text":"原题pdf：click here 日本的亚洲区域赛真心简单啊。两个小时就刷了5题有余了。排名第一的队伍才做出7道。 题目真心长的可以了，看了半个小时才明白。。 题意其实也就是太空中向前方抛小球，问小球能够穿过N个障碍物后到达制定地点的最小初始速度是多少。非常暴力的模拟题。离散化后直接枚举弹跳的次数再取最小值即可。注意45°方向能成功的话，那还是45°最优。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set::iterator#define VI(x) vector::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set::reverse_iterator#define VRI(x) vector::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;#define eps 1e-8/*start*/int d, n, b;PR ob[20];vector&amp;lt;pair&amp;lt;double, double&amp;gt; &amp;gt; vt;pair&amp;lt;double, double&amp;gt; dpr;double a[2][2], e[2];pair&amp;lt;double, double&amp;gt; Cramer(pair&amp;lt;double, double&amp;gt; dpr) &#123; pair&amp;lt;double, double&amp;gt; res; a[1][0] = dpr.F * dpr.F; a[1][1] = dpr.F; e[1] = dpr.S; double div = a[0][0] * a[1][1] - a[1][0] * a[0][1]; res.F = (e[0] * a[1][1] - e[1] * a[0][1]) / div; res.S = (e[1] * a[0][0] - e[0] * a[1][0]) / div; return res;&#125;int main(int argc, char **argv) &#123; while (~scanf(\"%d%d%d\", &amp;amp;d, &amp;amp;n, &amp;amp;b)) &#123; for (int i = 0; i &amp;lt; n; i++) &#123; scanf(\"%d%d\", &amp;amp;ob[i].F, &amp;amp;ob[i].S); &#125; double ans = inf; for (int c = 0; c &amp;lt;= b; c++) &#123;//enumerate the times bullet bounces the surface double dist = 1.0 * d / (c + 1); int f = 1; a[0][0] = dist * dist; a[0][1] = dist; e[0] = 0; vt.clear(); for (int i = 0; i &amp;lt; n; i++) &#123; dpr = ob[i]; while (dpr.F + eps &amp;gt;= dist) &#123; dpr.F -= dist; &#125; if (dpr.F &amp;lt;= eps) &#123; f = 0; break; &#125; vt.push_back(dpr); &#125; if (f == 0) continue; pair&amp;lt;double, double&amp;gt; res; for (int i = 0; i &amp;lt; Sz(vt); i++) &#123; dpr = vt[i]; if (i == 0) &#123; res = Cramer(dpr); &#125; else &#123; double tmph = dpr.F * dpr.F * res.F + dpr.F * res.S; if (tmph + eps &amp;lt; dpr.S) &#123; res = Cramer(dpr); &#125; &#125; &#125; res.F = -1.0 / (2 * res.F); res.S = res.F * res.S * res.S; ans = min(ans, sqrt(res.F + res.S)); //if the vector's angle is less than 45 if (res.S + eps &amp;lt; res.F) ans = min(ans, sqrt(dist)); &#125; printf(\"%.5f\\n\", ans); &#125;&#125;"},{"title":"优化Wine程序的字体显示","permalink":"http://sfork.coding.me/2014/10/13/wine-font-config/","text":"默认Wine的字体太难看，而且有时候还会显示不出来。开启Wine字体的反锯齿及平滑功能以及将字体映射成文泉驿微米黑的方法是： 1.新建文本文件a.reg，放入如下内容：12345678910111213141516171819202122232425262728293031323334353637REGEDIT4[HKEY_CURRENT_USER\\Software\\Wine\\X11 Driver]&quot;ClientSideAntiAliasWithCore&quot;=&quot;Y&quot;&quot;ClientSideAntiAliasWithRender&quot;=&quot;Y&quot;&quot;ClientSideWithRender&quot;=&quot;Y&quot;[HKEY_CURRENT_USER\\Control Panel\\Desktop]&quot;FontSmoothing&quot;=&quot;2&quot;&quot;FontSmoothingType&quot;=dword:00000002&quot;FontSmoothingGamma&quot;=dword:00000578&quot;FontSmoothingOrientation&quot;=dword:00000001[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes]&quot;Arial Baltic,186&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Arial CE,238&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Arial CYR,204&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Arial Greek,161&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Arial TUR,162&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Courier New Baltic,186&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Courier New CE,238&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Courier New CYR,204&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Courier New Greek,161&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Courier New TUR,162&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Helv&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Helvetica&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;MS Shell Dlg&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;MS Shell Dlg 2&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Tahoma&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Times&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Times New Roman Baltic,186&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Times New Roman CE,238&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Times New Roman CYR,204&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Times New Roman Greek,161&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Times New Roman TUR,162&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Tms Rmn&quot;=&quot;WenQuanYi Micro Hei&quot;&quot;Simsun&quot;=&quot;WenQuanYi Micro Hei&quot; 2.如果是普通的wine直接终端输入wine regedit打开注册表编辑器。然后点击“注册表—&gt;导入注册表文件”导入该文件。 3.如果是longene等封装好的wine（比如tm2013）可以使用tm2013 -reg命令打开注册表。"},{"title":"用Sublime Text 3 dev 做网页开发的配置","permalink":"http://sfork.coding.me/2014/09/16/sublime-config-web/","text":"文件：click here"},{"title":"我的xfce4配置","permalink":"http://sfork.coding.me/2014/09/16/xfce4-config/","text":"1.字体：infinally 渲染 2.英文字体：courier prime 3.窗口最大化隐藏标题栏：xfwm4-titleless-dev 4.窗口最大化标题栏隐藏后，在任务栏上显示控制按钮的插件：xfce4-windowck-plugin"},{"title":"HDU 4965 Fast Matrix Calculation","permalink":"http://sfork.coding.me/2014/08/19/hdu-4965-fast-matrix-calculation/","text":"Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others)Total Submission(s): 206 Accepted Submission(s): 116 Problem Description One day, Alice and Bob felt bored again, Bob knows Alice is a girl who loves math and is just learning something about matrix, so he decided to make a crazy problem for her. Bob has a six-faced dice which has numbers 0, 1, 2, 3, 4 and 5 on each face. At first, he will choose a number N (4 &lt;= N &lt;= 1000), and for N times, he keeps throwing his dice for K times (2 &lt;=K &lt;= 6) and writes down its number on the top face to make an NK matrix A, in which each element is not less than 0 and not greater than 5. Then he does similar thing again with a bit difference: he keeps throwing his dice for N times and each time repeat it for K times to write down a KN matrix B, in which each element is not less than 0 and not greater than 5. With the two matrix A and B formed, Alice’s task is to perform the following 4-step calculation.Step 1: Calculate a new NN matrix C = AB.Step 2: Calculate M = C^(N*N).Step 3: For each element x in M, calculate x % 6. All the remainders form a new matrix M’.Step 4: Calculate the sum of all the elements in M’. Bob just made this problem for kidding but he sees Alice taking it serious, so he also wonders what the answer is. And then Bob turn to you for help because he is not good at math. &nbsp; Input The input contains several test cases. Each test case starts with two integer N and K, indicating the numbers N and K described above. Then N lines follow, and each line has K integers between 0 and 5, representing matrix A. Then K lines follow, and each line has N integers between 0 and 5, representing matrix B. The end of input is indicated by N = K = 0. &nbsp; Output For each case, output the sum of all the elements in M’ in a line. &nbsp; Sample Input 4 2 5 5 4 4 5 4 0 0 4 2 5 5 1 3 1 5 6 3 1 2 3 0 3 0 2 3 4 4 3 2 2 5 5 0 5 0 3 4 5 1 1 0 5 3 2 3 3 2 3 1 5 4 5 2 0 0 &nbsp; Sample Output 14 56 &nbsp; Source 2014 Multi-University Training Contest 9 这题让我注意了矩阵模板的开销问题。1000X1000多次调用就会爆内存了。下面是用动态数组写的。效率非常慢，难以接受。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;/*start*/#define MOD 6int n, k;struct Matrix &#123; int n, m; int** M; Matrix(int n, int m) :n(n), m(m) &#123; M = new int*[n]; for (int i = 0; i &amp;lt; n; i++) M[i] = new int[m]; &#125; Matrix(int n, int m, int k) : n(n), m(m) &#123; M = new int*[n]; for (int i = 0; i &amp;lt; n; i++) M[i] = new int[m]; Init(k); &#125; ~Matrix() &#123; if (M) &#123; for (int i = 0; i &amp;lt; n; i++) &#123; if (M[i]) &#123; delete[] M[i]; M[i] = NULL; &#125; &#125; delete[] M; M = NULL; &#125; &#125; void Init(bool k) &#123; //k=1 返回单位矩阵，k=0 返回零矩阵 for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) M[i][j] = k * (i == j); &#125; void out() &#123; for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) printf(\"%d%c\", M[i][j], j == m - 1 ? '\\n' : ' '); &#125; Matrix &amp;amp; operator=(const Matrix&amp;amp; othr) &#123; this-&amp;gt;~Matrix(); n = othr.n; m = othr.m; M = new int*[n]; for (int i = 0; i &amp;lt; n; i++) M[i] = new int[m]; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; m; j++) &#123; M[i][j] = othr.M[i][j]; &#125; &#125; return *this; &#125; Matrix(const Matrix &amp;amp; othr) &#123; n = othr.n; m = othr.m; M = new int*[n]; for (int i = 0; i &amp;lt; n; i++) M[i] = new int[m]; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; m; j++) &#123; M[i][j] = othr.M[i][j]; &#125; &#125; &#125; bool operator==(const Matrix&amp;amp; othr) const &#123; if (n - othr.n || m - othr.m) return false; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; m; j++) &#123; if (M[i][j] != othr.M[i][j]) return false; &#125; &#125; return true; &#125; Matrix operator *(const Matrix&amp;amp; othr) const &#123; if (m - othr.n) exit(1); //异常退出 Matrix ans(n, othr.m, 0); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; othr.m; j++) for (int k = 0; k &amp;lt; m; k++) &#123; ans.M[i][j] += M[i][k] * othr.M[k][j] % MOD; if (ans.M[i][j] &amp;gt;= MOD) ans.M[i][j] -= MOD; if (ans.M[i][j] &amp;lt; 0) ans.M[i][j] += MOD; &#125; return ans; &#125; Matrix operator *(const int&amp;amp; x) const &#123; Matrix ans(n, m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) ans.M[i][j] = M[i][j] * x % MOD; return ans; &#125; Matrix operator +(const Matrix &amp;amp; othr) const &#123; if (n - othr.n || m - othr.m) exit(1); Matrix ans(n, m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) &#123; ans.M[i][j] = M[i][j] + othr.M[i][j]; if (ans.M[i][j] &amp;gt;= MOD) ans.M[i][j] -= MOD; if (ans.M[i][j] &amp;lt; 0) ans.M[i][j] += MOD; &#125; return ans; &#125; Matrix operator -(const Matrix&amp;amp; othr) const &#123; if (n - othr.n || m - othr.m) exit(1); Matrix ans(n, m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) &#123; ans.M[i][j] = M[i][j] - othr.M[i][j]; if (ans.M[i][j] &amp;gt;= MOD) ans.M[i][j] -= MOD; if (ans.M[i][j] &amp;lt; 0) ans.M[i][j] += MOD; &#125; return ans; &#125; Matrix operator ^(int x) const &#123; if (n - m) exit(1); Matrix ans(n, m, 1), base = *this; while (x &amp;gt; 0) &#123; if (x &amp;amp; 1) ans = ans * base; base = base * base; x &amp;gt;&amp;gt;= 1; &#125; return ans; &#125;&#125;;int main(int argc, char **argv) &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;k)) &#123; if (n == 0 &amp;amp;&amp;amp; k == 0) break; Matrix A(n, k, 0), B(k, n, 0); for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; k; j++) &#123; scanf(\"%d\", &amp;amp;A.M[i][j]); &#125; &#125; for (int i = 0; i &amp;lt; k; i++) &#123; for (int j = 0; j &amp;lt; n; j++) &#123; scanf(\"%d\", &amp;amp;B.M[i][j]); &#125; &#125; Matrix mat = B * A; int r = n * n - 1; Matrix res = A * (mat ^ r) * B; int ans = 0; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; n; j++) &#123; ans += res.M[i][j]; &#125; &#125; printf(\"%d\\n\", ans); &#125;&#125; 然后又试了试vector，虽然简单不少，但是仍然很慢：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;/*start*/#define MOD 6int n, k;struct Matrix &#123; int n, m; vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;M; Matrix(int n, int m) :n(n), m(m) &#123; alloc(); &#125; Matrix(int n, int m, int k) : n(n), m(m) &#123; alloc(); Init(k); &#125; void alloc()&#123; M.resize(n); for (int i = 0; i &amp;lt; n; i++) M[i].resize(m); &#125; void Init(bool k) &#123; //k=1 返回单位矩阵，k=0 返回零矩阵 for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) M[i][j] = k * (i == j); &#125; void out() &#123; for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) printf(\"%d%c\", M[i][j], j == m - 1 ? '\\n' : ' '); &#125; bool operator==(const Matrix&amp;amp; othr) const &#123; if (n - othr.n || m - othr.m) return false; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; m; j++) &#123; if (M[i][j] != othr.M[i][j]) return false; &#125; &#125; return true; &#125; Matrix operator *(const Matrix&amp;amp; othr) const &#123; if (m - othr.n) exit(1); //异常退出 Matrix ans(n, othr.m, 0); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; othr.m; j++) for (int k = 0; k &amp;lt; m; k++) &#123; ans.M[i][j] += M[i][k] * othr.M[k][j] % MOD; if (ans.M[i][j] &amp;gt;= MOD) ans.M[i][j] -= MOD; if (ans.M[i][j] &amp;lt; 0) ans.M[i][j] += MOD; &#125; return ans; &#125; Matrix operator *(const int&amp;amp; x) const &#123; Matrix ans(n, m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) ans.M[i][j] = M[i][j] * x % MOD; return ans; &#125; Matrix operator +(const Matrix &amp;amp; othr) const &#123; if (n - othr.n || m - othr.m) exit(1); Matrix ans(n, m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) &#123; ans.M[i][j] = M[i][j] + othr.M[i][j]; if (ans.M[i][j] &amp;gt;= MOD) ans.M[i][j] -= MOD; if (ans.M[i][j] &amp;lt; 0) ans.M[i][j] += MOD; &#125; return ans; &#125; Matrix operator -(const Matrix&amp;amp; othr) const &#123; if (n - othr.n || m - othr.m) exit(1); Matrix ans(n, m); for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; m; j++) &#123; ans.M[i][j] = M[i][j] - othr.M[i][j]; if (ans.M[i][j] &amp;gt;= MOD) ans.M[i][j] -= MOD; if (ans.M[i][j] &amp;lt; 0) ans.M[i][j] += MOD; &#125; return ans; &#125; Matrix operator ^(int x) const &#123; if (n - m) exit(1); Matrix ans(n, m, 1), base = *this; while (x &amp;gt; 0) &#123; if (x &amp;amp; 1) ans = ans * base; base = base * base; x &amp;gt;&amp;gt;= 1; &#125; return ans; &#125;&#125;;int main(int argc, char **argv) &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;k)) &#123; if (n == 0 &amp;amp;&amp;amp; k == 0) break; Matrix A(n, k, 0), B(k, n, 0); for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; k; j++) &#123; scanf(\"%d\", &amp;amp;A.M[i][j]); &#125; &#125; for (int i = 0; i &amp;lt; k; i++) &#123; for (int j = 0; j &amp;lt; n; j++) &#123; scanf(\"%d\", &amp;amp;B.M[i][j]); &#125; &#125; Matrix mat = B * A; int r = n * n - 1; Matrix res = A * (mat ^ r) * B; int ans = 0; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; n; j++) &#123; ans += res.M[i][j]; &#125; &#125; printf(\"%d\\n\", ans); &#125;&#125; 感觉其他方法还比较麻烦。算了就这样吧~ &nbsp;"},{"title":"HDU 4952 Number Transformation","permalink":"http://sfork.coding.me/2014/08/15/hdu-4952-number-transformation/","text":"Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 612 Accepted Submission(s): 310 Problem Description Teacher Mai has an integer x. He does the following operations k times. In the i-th operation, x becomes the least integer no less than x, which is the multiple of i. He wants to know what is the number x now. &nbsp; Input There are multiple test cases, terminated by a line “0 0”. For each test case, the only one line contains two integers x,k(1&lt;=x&lt;=10^10, 1&lt;=k&lt;=10^10). &nbsp; Output For each test case, output one line “Case #k: x”, where k is the case number counting from 1. &nbsp; Sample Input 2520 10 2520 20 0 0 &nbsp; Sample Output Case #1: 2520 Case #2: 2600 &nbsp; Source 2014 Multi-University Training Contest 8 &nbsp; Recommend hujie | We have carefully selected several similar problems for you: 4955 4954 4953 4951 4950 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;/*start*/int __;#define type LLinline type getint() &#123; type ret=0;bool ok=0; for(;;) &#123; int c=getchar(); if(c&amp;gt;='0'&amp;amp;&amp;amp;c&amp;lt;='9')ret=(ret&amp;lt;&amp;lt;3)+ret+ret+c-'0',ok=1; else if(ok)return ret; &#125;&#125;#undef typeint main(int argc, char **argv) &#123; LL x, k; while (1) &#123; x=getint(); k=getint(); if (x == 0 &amp;amp;&amp;amp; k == 0) break; for(int i=1;i&amp;lt;k;i++)&#123; if(x&amp;lt;i+1)break; x-=x/(i+1); &#125; printf(\"Case #%d: \"LLS\"\\n\",++__,x*k); &#125;&#125;"},{"title":"HDU 4945 2048","permalink":"http://sfork.coding.me/2014/08/15/hdu-4945-2048/","text":"Time Limit: 3000/1500 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 590 Accepted Submission(s): 136 Problem Description Teacher Mai is addicted to game 2048. But finally he finds it’s too hard to get 2048. So he wants to change the rule: You are given some numbers. Every time you can choose two numbers of the same value from them and merge these two numbers into their sum. And these two numbers disappear meanwhile. If we can get 2048 from a set of numbers with this operation, Teacher Mai think this multiset is good. You have n numbers, A1,…,An. Teacher Mai ask you how many subsequences of A are good. The number can be very large, just output the number modulo 998244353. &nbsp; Input There are multiple test cases, terminated by a line “0”. For each test case, the first line contains an integer n (1&lt;=n&lt;=10^5), the next line contains n integers ai (0&lt;=ai&lt;=2048). &nbsp; Output For each test case, output one line “Case #k: ans”, where k is the case number counting from 1, ans is the number module 998244353. &nbsp; Sample Input 4 1024 512 256 256 4 1024 1024 1024 1024 5 1024 512 512 512 1 0 &nbsp; Sample Output Case #1: 1 Case #2: 11 Case #3: 8 HintIn the first case, we should choose all the numbers. In the second case, all the subsequences which contain more than one number are good. &nbsp; &nbsp; Source 2014 Multi-University Training Contest 8 &nbsp; Recommend hujie | We have carefully selected several similar problems for you: 4955 4954 4953 4952 4951 貌似这几天第一次做的DP题啊。想象一下二进制就能明白——当子序列的2次幂数字之和大于等于2048时这个序列就是good序列了。正面dp要dp出2048~100000肯定要超时，而反面dp只需要dp出0~2047就够了。复杂度大大降低O（11＊2048*2048）。 标程写的很厉害！尤其是逆元的处理！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;/*start*/#define MOD 998244353int cnt[3010];LL f[101000], g[101000];int pn, n, __;int dp[13][1025]; //表示取了2^0、2^1、2^2、……、2^i种元素，总和加起来等于j*2^(i+1)的所有情况inline int getint() &#123; int ret = 0; bool ok = 0; for (;;) &#123; int c = getchar(); if (c &amp;gt;= '0' &amp;amp;&amp;amp; c &amp;lt;= '9') ret = (ret &amp;lt;&amp;lt; 3) + ret + ret + c - '0', ok = 1; else if (ok) return ret; &#125;&#125;inline LL powmod(LL b, int x) &#123; LL res = 1; for (b %= MOD; x; x &amp;gt;&amp;gt;= 1) &#123; if (x &amp;amp; 1) res = res * b % MOD; b = b * b % MOD; &#125; return res;&#125;int main(int argc, char **argv) &#123; f[0] = 1; for (int i = 1; i &amp;lt;= 100000; i++) f[i] = f[i - 1] * i % MOD; g[100000] = powmod(f[100000], MOD - 2); for (int i = 99999; i &amp;gt;= 0; i--) g[i] = g[i + 1] * (i + 1) % MOD; while (1) &#123; n = getint(); if (n == 0) break; for (int k = 1; k &amp;lt;= 2048; k &amp;lt;&amp;lt;= 1) cnt[k] = 0; for (int i = 0; i &amp;lt; n; i++) &#123; cnt[getint()]++; &#125; pn = 0; for (int k = 1; k &amp;lt;= 2048; k &amp;lt;&amp;lt;= 1) pn += cnt[k]; for (int i = 0, m = 1024; i &amp;lt;= 11; i++, m &amp;gt;&amp;gt;= 1) &#123; for (int j = 0; j &amp;lt;= m; j++) &#123; dp[i][j] = 0; &#125; &#125; int ct = cnt[1]; LL cof = f[ct]; for (int i = 0; i &amp;lt;= ct &amp;amp;&amp;amp; i &amp;lt; 2048; i++) &#123; dp[0][i &amp;gt;&amp;gt; 1] += g[ct - i] * g[i] % MOD; if (dp[0][i &amp;gt;&amp;gt; 1] &amp;gt; MOD) dp[0][i &amp;gt;&amp;gt; 1] -= MOD; &#125; for (int i = 1, m = 1024; i &amp;lt;= 11; i++, m &amp;gt;&amp;gt;= 1) &#123; ct = cnt[1 &amp;lt;&amp;lt; i]; cof = cof * f[ct] % MOD; for (int j = 0; j &amp;lt; m; j++) &#123; if (dp[i - 1][j]) &#123; for (int k = 0; k &amp;lt;= ct &amp;amp;&amp;amp; j + k &amp;lt; m; k++) &#123;//不要把满足good的序列转移上去。 dp[i][(j + k) &amp;gt;&amp;gt; 1] += dp[i - 1][j] * g[k] % MOD * g[ct - k] % MOD; if (dp[i][(j + k) &amp;gt;&amp;gt; 1] &amp;gt; MOD) dp[i][(j + k) &amp;gt;&amp;gt; 1] -= MOD; &#125; &#125; &#125; &#125; int ans = (powmod(2, pn) - dp[11][0] * cof) % MOD * powmod(2, n - pn)%MOD; if (ans &amp;lt; 0) ans += MOD; printf(\"Case #%d: %d\\n\", ++__, ans); &#125;&#125;"},{"title":"我的HerbstluftWM","permalink":"http://sfork.coding.me/2014/08/14/herbustluftwm-config/","text":"一直以来想折腾一下WM，但是又感觉麻烦。前天把笔记本带到机房就借此机会在虚拟机中玩了一下。发现事实上比我想像的要简单的多。少量配置了一下两个配置文件就能用了。然后使用compton做透明特效。看起来也挺简洁美观的。 WM最大的特点就是轻便，herbstluftWM也不例外。安装只有几百兆，附加依赖少，几乎一个命令的事情。启动、响应速度都是普通DE无法比拟的快。加上compton的透明效果，稍加修饰整个系统的界面就非常美观了。 两个配置文件与更详细的说明我已经push到了github：click here"},{"title":"HDU 2874 Connections between cities","permalink":"http://sfork.coding.me/2014/08/13/hdu-2874-connections-between-cities/","text":"Connections between citiesTime Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 4759 Accepted Submission(s): 1341 Problem Description After World War X, a lot of cities have been seriously damaged, and we need to rebuild those cities. However, some materials needed can only be produced in certain places. So we need to transport these materials from city to city. For most of roads had been totally destroyed during the war, there might be no path between two cities, no circle exists as well.Now, your task comes. After giving you the condition of the roads, we want to know if there exists a path between any two cities. If the answer is yes, output the shortest path between them. &nbsp; Input Input consists of multiple problem instances.For each instance, first line contains three integers n, m and c, 2&lt;=n&lt;=10000, 0&lt;=m&lt;10000, 1&lt;=c&lt;=1000000. n represents the number of cities numbered from 1 to n. Following m lines, each line has three integers i, j and k, represent a road between city i and city j, with length k. Last c lines, two integers i, j each line, indicates a query of city i and city j. &nbsp; Output For each problem instance, one line for each query. If no path between two cities, output “Not connected”, otherwise output the length of the shortest path between them. &nbsp; Sample Input 5 3 2 1 3 2 2 4 3 5 2 3 1 4 4 5 &nbsp; Sample Output Not connected 6 HintHint Huge input, scanf recommended. &nbsp; Source 2009 Multi-University Training Contest 8 - Host by BJNU 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;/*start*/#define N 10004#define M 10005int n, m, c;struct Edge &#123; int v, w, nxt;&#125; e[M &amp;lt;&amp;lt; 1];int head[N], ecnt;void initEdge() &#123; memset(head, -1, sizeof(head)); ecnt = 0;&#125;void add(int u, int v, int w) &#123; e[ecnt].v = v; e[ecnt].w = w; e[ecnt].nxt = head[u]; head[u] = ecnt++;&#125;//RMQint dpM[20][N &amp;lt;&amp;lt; 1];int lg2[N &amp;lt;&amp;lt; 1];#define getL(R,L) (R-(L)+1)void initRMQ(int n) &#123; lg2[0] = -1; int m; for (int i = 1; i &amp;lt;= n; i++) lg2[i] = i &amp;amp; (i - 1) ? lg2[i - 1] : lg2[i - 1] + 1; for (int i = 1; i &amp;lt;= lg2[n]; i++) &#123; m = getL(n, 1 &amp;lt;&amp;lt; i); for (int j = 1; j &amp;lt;= m; j++) &#123; dpM[i][j] = min(dpM[i - 1][j], dpM[i - 1][j + (1 &amp;lt;&amp;lt; (i - 1))]); &#125; &#125;&#125;int getRMQ(int a, int b) &#123; if (a &amp;gt; b) swap(a, b); int s = lg2[b - a + 1]; return min(dpM[s][a], dpM[s][getL(b, 1 &amp;lt;&amp;lt; s)]);&#125;//LCAint E[N];int T[N];int H[N];int depth, cnt;int belong[N], bcnt;int findRoot() &#123; for (int i = 1; i &amp;lt;= n; i++) &#123; if (belong[i] == 0) return i; &#125; return -1;&#125;void getEuler(int u, int fa = -1) &#123; int tmp = dpM[0][H[u] = ++cnt] = ++depth; E[tmp] = u; belong[u] = bcnt; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; if (v == fa) continue; T[v] = T[u] + e[i].w; getEuler(v, u); dpM[0][++cnt] = tmp; &#125;&#125;void initLCA() &#123; memset(T, 0, sizeof(T)); memset(belong, 0, sizeof(belong)); bcnt = cnt = depth = 0; int root; while ((root = findRoot()) != -1) &#123; ++bcnt; getEuler(root); &#125; initRMQ(cnt);&#125;int getLCA(int u, int v) &#123; if (belong[u] != belong[v]) return -1; if (H[u] &amp;gt; H[v]) swap(u, v); return E[getRMQ(H[u], H[v])];&#125;int main(int argc, char **argv) &#123; while (~scanf(\"%d%d%d\", &amp;amp;n, &amp;amp;m, &amp;amp;c)) &#123; initEdge(); int u, v, w; for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d%d\", &amp;amp;u, &amp;amp;v, &amp;amp;w); add(u, v, w); add(v, u, w); &#125; initLCA(); while (c--) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); int r = getLCA(u, v); if (r == -1) puts(\"Not connected\"); else &#123; printf(\"%d\\n\", T[u] + T[v] - 2 * T[r]); &#125; &#125; &#125;&#125;"},{"title":"内网 2085马农","permalink":"http://sfork.coding.me/2014/08/13/zjnu2085/","text":"##Description 在观看完战马检阅之后，来自大草原的两兄弟决心成为超级“马农”，专门饲养战马。 兄弟两回到草原，将可以养马的区域，分为N*N的单位面积的正方形，并实地进行考察，归纳出了每个单位面积可以养马所获得的收益。接下来就要开始规划他们各自的马场了。 首先，两人的马场都必须是矩形区域。同时，为了方便两人互相照应，也为了防止马匹互相走散，规定两个马场的矩形区域相邻，且只有一个交点。最后，互不认输的两人希望两个马场的收益相当，这样才不会影响他们兄弟的感情。 现在，兄弟两找到你这位设计师，希望你给他们设计马场，问共有多少种设计方案。 ##Input 第一行一个整数N，表示整个草原的大小为N*N。 接下来N行，每行N个整数A(i,j)，表示第i行第j列的单位草地的收成。（注意：收益可能是负数，养马也不是包赚的，马匹也可能出现生病死亡等意外。） 1&lt;=N&lt;=50-1000&lt;A(i,j)&lt;1000 ##Output 输出符合两人要求的草原分配方案数。 ##Sample Input 3 1 2 3 4 5 6 7 8 9 ##Sample Output 2 ##Hint ##Source 2014宁波初中 T2 宁波镇海中学的罗方炜给我们组的一场比赛。 此题主要靠技巧。枚举中心点，然后用数组hash。注意数组清空复杂度很大，每次清空必定超时。应该用一个栈来记录更改的地方，直接赋0. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define PR pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define Sz(x) (int)x.size()#define clrQ(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;/*start*/#define N 55#define M 2500000int f[N][N],a[N][N];int h[M&amp;lt;&amp;lt;1|1];int st[N*N],top;int n,m;int main(int argc, char **argv) &#123; while(~scanf(\"%d\",&amp;amp;n))&#123; for (int i = 1; i &amp;lt;= n; ++i) &#123; for (int j = 1; j &amp;lt;= n; ++j) &#123; scanf(\"%d\",&amp;amp;a[i][j]); f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+a[i][j]; &#125; &#125; int res=top=0; for (int x = 1; x &amp;lt;= n; ++x) &#123; for (int y = 1; y &amp;lt;= n; ++y) &#123; for (int i = 1; i &amp;lt;= x; ++i) &#123; for (int j = 1; j &amp;lt;= y; ++j) &#123; st[top++]=f[x][y]-f[x][j-1]-f[i-1][y]+f[i-1][j-1]+M; h[st[top-1]]++; &#125; &#125; for (int i = x+1; i &amp;lt;= n; ++i) &#123; for (int j = y+1; j &amp;lt;= n; ++j) &#123; res+=h[f[i][j]-f[i][y]-f[x][j]+f[x][y]+M]; &#125; &#125; while(top)&#123; h[st[--top]]=0; &#125; for (int i = x; i &amp;lt;= n; ++i) &#123; for (int j = 1; j &amp;lt;= y; ++j) &#123; st[top++]=f[i][y]-f[x-1][y]-f[i][j-1]+f[x-1][j-1]+M; h[st[top-1]]++; &#125; &#125; for (int i = 1; i &amp;lt; x; ++i) &#123; for (int j = y+1; j &amp;lt;= n; ++j) &#123; res+=h[f[x-1][j]-f[x-1][y]-f[i-1][j]+f[i-1][y]+M]; &#125; &#125; while(top)&#123; h[st[--top]]=0; &#125; &#125; &#125; printf(\"%d\\n\",res); &#125;&#125;"},{"title":"内网2082 字母","permalink":"http://sfork.coding.me/2014/08/12/zjnu2082/","text":"##Description 乐乐开始学习英文字母了，小C为他准备了很多字母牌，每张牌有一个英文字母。有天乐乐把所有的牌排成一行，这些字母竟然形成了一个回文串。小C想知道，乐乐在排字母的时候，有多少种情况，最后的字母形成回文串。 ##Input 输入一行，表示乐乐有哪些字母，均大写。 ##Output 输出有多少种情况，排列的字母是一个回文串。 ##Sample InputAAAAB AABB CD ##Sample Output 1 2 0 ##Hint100%的数据，字母的个数不超过1000。 A(m,m)/(A(cnt1,cnt1)*A(cnt2,cnt2)…….) 主要是排列组合数的计算技巧。将n!分解质因数，然后上面的因子减去下面相同的因子，这样就不会因为计算阶乘而爆数组了。n!中质因数m的个数：n/m+n/m^2+n/m^3+n/m^4………123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include \"iostream\"#include \"cstdio\"#include \"cstring\"#include \"string\"#include \"vector\"using namespace std;#define sz(x) (int)x.size()#define DSIZE 10000#define clr(x,y) memset(x,y,sizeof(x));class BigInteger &#123;private: int a[1001]; bool sign; //true-p , false-n int len;public: BigInteger() &#123; len = 1; sign = true; clr(a, 0); a[0] = 1; &#125; void operator *=(int); friend ostream &amp;amp;operator&amp;lt;&amp;lt;(ostream &amp;amp;, const BigInteger &amp;amp;);&#125;;void BigInteger::operator*=(int x) &#123; if (x &amp;lt; 0) x = -x, sign ^= 1; for (int i = 0; i &amp;lt; len; i++) &#123; a[i] *= x; &#125; for (int i = 0; i &amp;lt; len; i++) &#123; if (a[i] &amp;gt;= DSIZE) &#123; a[i + 1] += a[i] / DSIZE; a[i] %= DSIZE; &#125; &#125; if (a[len]) len++;&#125;ostream &amp;amp;operator&amp;lt;&amp;lt;(ostream &amp;amp;out, const BigInteger &amp;amp;x) &#123; if (!x.sign &amp;amp;&amp;amp; x.len) putchar('-'); printf(\"%d\", x.a[x.len - 1]); for (int i = x.len - 2; i &amp;gt;= 0; i--) &#123; printf(\"%04d\", x.a[i]); &#125; return out;&#125;int n, m;int cnt[30];int prime[1001], tot;bool ok[1001];int faclist[1001];void getprime(int n) &#123; clr(ok, 0); tot = 0; for (int i = 2; i &amp;lt;= n; i++) &#123; if (!ok[i]) prime[tot++] = i; for (int j = 0; j &amp;lt; tot; j++) &#123; int now = i * prime[j]; if (now &amp;gt; n) break; ok[now] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;void getfact(int x) &#123; int s = x &amp;lt; 0 ? -x : x; for (int i = 0; prime[i] &amp;lt;= s; i++) &#123; for (int j = prime[i]; j &amp;lt;= s; j *= prime[i]) &#123; faclist[i] += x / j; &#125; &#125;&#125;char str[1001];int main() &#123; getprime(1000); while (~scanf(\"%s\",str)) &#123; n = strlen(str); clr(cnt, 0); for (int i = 0; i &amp;lt; n; i++) &#123; cnt[str[i] - 'A']++; &#125; int f = 0; m = 0; for (int i = 0; i &amp;lt; 26 &amp;amp;&amp;amp; f &amp;lt; 2; i++) &#123; if (cnt[i] &amp;amp; 1) f++; m += cnt[i] &amp;gt;&amp;gt;= 1; &#125; if (f &amp;gt; 1) &#123; printf(\"0\\n\"); continue; &#125; clr(faclist, 0); getfact(m); for (int i = 0; i &amp;lt; 26; i++) getfact(-cnt[i]); BigInteger res; for (int i = 0; prime[i] &amp;lt;= m; i++) &#123; for (int j = 0; j &amp;lt; faclist[i]; j++) &#123; res *= prime[i]; &#125; &#125; cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl; &#125;&#125;```language"},{"title":"HDU4944 FSF’s game","permalink":"http://sfork.coding.me/2014/08/12/hdu4944-fsfs-game/","text":"Time Limit: 9000/4500 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others)Total Submission(s): 166 Accepted Submission(s): 76 Problem Description FSF has programmed a game.In this game, players need to divide a rectangle into several same squares.The length and width of rectangles are integer, and of course the side length of squares are integer. After division, players can get some coins.If players successfully divide a AxB rectangle(length: A, width: B) into KxK squares(side length: K), they can get AB/ gcd(A/K,B/K) gold coins.In a level, you can’t get coins twice with same method.(For example, You can get 6 coins from 2x2(A=2,B=2) rectangle. When K=1, AB/gcd(A/K,B/K)=2; When K=2, AB/gcd(A/K,B/K)=4; 2+4=6; )There are N(N+1)/2 levels in this game, and every level is an unique rectangle. (1x1 , 2x1, 2x2, 3x1, …, Nx(N-1), NxN) FSF has played this game for a long time, and he finally gets all the coins in the game.Unfortunately ,he uses an UNSIGNED 32-BIT INTEGER variable to count the number of coins.This variable may overflow.We want to know what the variable will be.(In other words, the number of coins mod 2^32) &nbsp; Input There are multiply test cases. The first line contains an integer T(T&lt;=500000), the number of test cases Each of the next T lines contain an integer N(N&lt;=500000). &nbsp; Output Output a single line for each test case. For each test case, you should output “Case #C: “. first, where C indicates the case number and counts from 1. Then output the answer, the value of that UNSIGNED 32-BIT INTEGER variable. &nbsp; Sample Input 3 1 3 100 &nbsp; Sample Output Case #1: 1Case #2: 30Case #3: 15662489 HintIn the second test case, there are six levels(1x1,1x2,1x3,2x2,2x3,3x3) Here is the details for this game: 1x1: 1(K=1); 1x2: 2(K=1); 1x3: 3(K=1); 2x2: 2(K=1), 4(K=2); 2x3: 6(K=1); 3x3: 3(K=1), 9(K=3); 1+2+3+2+4+6+3+9=30 &nbsp; Author UESTC &nbsp; Source 2014 Multi-University Training Contest 7 &nbsp; Recommend We have carefully selected several similar problems for you: 4943 4942 4941 4940 4939 N(LogN)的复杂度。123456789101112131415161718192021222324#include&amp;lt;cstdio&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;#define N 500001unsigned int f[N];unsigned int g[N];int n;int main() &#123; int T; for (int i = 1; i &amp;lt; N; i++) &#123; for (int j = 1; i * j &amp;lt; N; j++) &#123; g[i * j] += (1LL + j) * j / 2; &#125; &#125; f[1] = 1; for (int i = 2; i &amp;lt; N; i++) &#123; f[i] = f[i - 1] + i * g[i]; &#125; scanf(\"%d\", &amp;amp;T); for (int c = 1; c &amp;lt;= T; c++) &#123; scanf(\"%d\", &amp;amp;n); printf(\"Case #%d: %u\\n\", c, f[n]); &#125;&#125;"},{"title":"github使用札记","permalink":"http://sfork.coding.me/2014/08/10/github-tips/","text":"生成ssh key: ssh-keygen -t rsa -C &quot;stkevintan@foxmail.com&quot; 输入合适的密码。然后将生成的pub公钥粘贴到github上：click here 版本推送命令： ### Create a new repository on the command line touch README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin &lt;span class=&quot;js-live-clone-url&quot;&gt;https://github.com/stkevintan/资源名.git&lt;/span&gt; &lt;span class=&quot;js-selectable-text&quot;&gt;git push -u origin master&lt;/span&gt;`&lt;/pre&gt; ### Push an existing repository from the command line &lt;pre&gt;`git remote add origin &lt;span class=&quot;js-live-clone-url&quot;&gt;https://github.com/stkevintan/资源名.git&lt;/span&gt; &lt;span class=&quot;js-selectable-text&quot;&gt;git push -u origin master&lt;/span&gt; 修改或删除passphrase。(Details)ssh-keygen -p"},{"title":"内网2073 城主GeassCode","permalink":"http://sfork.coding.me/2014/08/01/zjnu2073-geasscode/","text":"##Description GeassCode凭借自己在topcoder上的超凡表现，赢得了国王的喜爱，国王赏赐他一座城池。这座城池里有n个 村子，m条路连接这些村子。坐上城主的GeassCode决定要修路，他打算用最少的代价把所以的村子连在一起。据探子回报，有些村子之间虽然原来没有路 径，但是可以强行的去建一条路。GeassCode想知道，如果强行在某两个村子之间建一条路，最后的总花费是多少？ ##Input 输入一行三个整数n，m，表示有n个村子，m条可建路径。 2..m+1行，每行3个整数a,b,c（a≠b），表示可以在a和b村庄建一条花费为c的路径。 第m+2行一个整数q，表示有多少个询问。 接下来q个询问，每行3个整数a,b,c（a≠b），表示如果可以另外在a和b村庄建一条花费为c的路径，最终需要多少花费？ ##Output 对于每个询问输出，输出最少的花费。 ##Sample Input4 5 1 2 4 2 3 3 1 4 6 2 4 3 1 3 2 3 3 4 3 1 3 1 1 4 2 ##Sample Output8 7 7 ##Hintn的范围[2,50000],m的范围[2,100000],q的范围[1,50000]。 输入的m条边保证可以把所有村庄连在一起。输入的边权范围[1,106] ##Source 张超 解法是如果可以在(u,v)上再加条边，则将最小生成树上的(u,v)节点最短路径中的最大边权与要加上这条边的替换。如果新的花费比旧的花费少，则取新的花费。否则什么也不换，取旧的花费。 如何求树上两点之间的最短路径中的最大边权呢？ 可以按照这篇文章所述建一个类似于哈夫曼树，将点作为叶子，边的权值作为祖先构造一个N+N的树：click here 这样写的很容易错，尤其要区分两颗树的规模，我在这上面错了很久。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;#define N 50005#define M 100005int n, m ;struct Graph &#123; int u, v, w; bool mark; bool operator&amp;lt;(Graph othr) const &#123; return w &amp;lt; othr.w; &#125;&#125; g[M];//UnionSetint p[N + N];void initUset(int n) &#123; for (int i = 0; i &amp;lt;= n; i++) p[i] = i;&#125;int uFind(int x) &#123; return x == p[x] ? p[x] : p[x] = uFind(p[x]);&#125;void uMerge(int x, int y) &#123; //y合并到x int fx = uFind(x); int fy = uFind(y); if (fx != fy) p[fy] = fx;&#125;//Edge Graphint head[N + N], pos;struct Edge &#123; int v, nxt;&#125; e[N + N];void initEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v) &#123; e[pos].v = v; e[pos].nxt = head[u]; head[u] = pos++;&#125;int size;vector&amp;lt;pr&amp;lt;int, int&amp;gt; &amp;gt; query[N];int qw[N];bool vis[N];int lca[N];int val[N + N];int dfs(int u) &#123; int solved = 0; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; solved += dfs(v); if (size == solved) return solved; uMerge(u, v); &#125; if(~val[u])return solved; vis[u] = 1; for (int i = 0; i &amp;lt; (int) query[u].size(); i++) &#123; int v = query[u][i].F; if (vis[v]) &#123; solved++; lca[query[u][i].S] = uFind(v); &#125; &#125; return solved;&#125;void tarjan() &#123; initUset(n); clrA(vis, 0); dfs(n);&#125;void rebuild() &#123; clrA(val, -1); initUset(n + n); initEdge(); for (int i = 1; i &amp;lt;= m; i++) &#123; if (g[i].mark == false) continue; val[++n] = g[i].w; int fu = uFind(g[i].u); int fv = uFind(g[i].v); p[fu] = n; p[fv] = n; add(n, fu); add(n, fv); &#125;&#125;int main() &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;m)) &#123; for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d%d\", &amp;amp;g[i].u, &amp;amp;g[i].v, &amp;amp;g[i].w); g[i].mark = false; &#125; sort(g + 1, g + 1 + m); initUset(n); LL sum = 0; for (int i = 1; i &amp;lt;= m; i++) &#123; int fx = uFind(g[i].u); int fy = uFind(g[i].v); if (fx != fy) &#123; sum += g[i].w; g[i].mark = true; p[fy] = fx; &#125; &#125; for (int i = 1; i &amp;lt;= n; i++) query[i].clear(); scanf(\"%d\", &amp;amp;size); int u, v, w; for (int i = 1; i &amp;lt;= size; i++) &#123; scanf(\"%d%d%d\", &amp;amp;u, &amp;amp;v, &amp;amp;w); qw[i] = w; query[u].push_back(MP(v, i)); query[v].push_back(MP(u, i)); &#125; rebuild(); tarjan(); for (int i = 1; i &amp;lt;= size; i++) &#123; LL ans = sum - val[lca[i]] + qw[i]; printf(LLS\"\\n\", min(ans, sum)); &#125; &#125;&#125; 其实，可以直接在dfs的回溯过程中将子节点的max求出来。这样简单多了。感叹一句：并查集真神奇！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair&amp;lt;int,int&amp;gt;#define MP make_pair#define SI(x) set&amp;lt;x &amp;gt;::iterator#define VI(x) vector&amp;lt;x &amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y &amp;gt;::iterator#define SRI(x) set&amp;lt;x &amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x &amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y &amp;gt;::reverse_iterator#define F first#define S second#define clrQ(x) while(!x.empty())x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;#define N 50005#define M 100005int n, m;struct Graph &#123; int u, v, w; bool operator&amp;lt;(Graph othr) const &#123; return w &amp;lt; othr.w; &#125;&#125; g[M];struct Pair &#123; int x, y; Pair(int x, int y) : x(x), y(y) &#123; &#125; ;&#125;;//Edge Graphint head[N], pos;struct Edge &#123; int v, w, nxt;&#125; e[N &amp;lt;&amp;lt; 1];void initEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v, int w) &#123; e[pos].v = v; e[pos].w = w; e[pos].nxt = head[u]; head[u] = pos++;&#125;//UnionSetint p[N];int pmax[N];void initUset() &#123; for (int i = 0; i &amp;lt;= n; i++) p[i] = i;&#125;int uFind(int x) &#123; if (x != p[x]) &#123; int t = p[x]; p[x] = uFind(p[x]); pmax[x] = max(pmax[x], pmax[t]); return p[x]; &#125; return x;&#125;void uMerge(int x, int y) &#123; //y合并到x int fx = uFind(x); int fy = uFind(y); if (fx != fy) &#123; p[fy] = fx; pmax[fy] = max(pmax[fy], pmax[fx]); &#125;&#125;int size;vector&amp;lt;Pair&amp;gt; query[N];vector&amp;lt;Pair&amp;gt; mark[N];int qw[N];bool vis[N];int lca[N];void dfs(int u, int fa) &#123; if (size == 0) return; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; if (v == fa) continue; dfs(v, u); pmax[v] = max(pmax[v], e[i].w); uMerge(u, v); &#125; vis[u] = 1; for (int i = 0; i &amp;lt; (int) query[u].size(); i++) &#123; int v = query[u][i].x; if (vis[v]) &#123; mark[uFind(v)].push_back(Pair(u, i)); &#125; &#125; if (!mark[u].empty()) &#123; for (VI(Pair)it=mark[u].begin();it!=mark[u].end();++it) &#123; int uu = it-&amp;gt;x; int vv = query[it-&amp;gt;x][it-&amp;gt;y].x; int ss = query[it-&amp;gt;x][it-&amp;gt;y].y; uFind(uu); uFind(vv); lca[ss] = max(pmax[uu], pmax[vv]); size--; &#125; mark[u].clear(); &#125;&#125;int findRoot() &#123; for (int i = 1; i &amp;lt;= n; i++) &#123; if (!vis[i]) return i; &#125; return assert(false), -1;&#125;void tarjan() &#123; initUset(); clrA(vis, 0); clrA(pmax, 0); size = m; dfs(findRoot(), -1);&#125;int main() &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;m)) &#123; for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d%d\", &amp;amp;g[i].u, &amp;amp;g[i].v, &amp;amp;g[i].w); &#125; sort(g + 1, g + 1 + m); initUset(); initEdge(); LL sum = 0; for (int i = 1; i &amp;lt;= m; i++) &#123; int fx = uFind(g[i].u); int fy = uFind(g[i].v); if (fx != fy) &#123; sum += g[i].w; add(g[i].u, g[i].v, g[i].w); add(g[i].v, g[i].u, g[i].w); p[fy] = fx; &#125; &#125; for (int i = 1; i &amp;lt;= n; i++) &#123; query[i].clear(); mark[i].clear(); &#125; scanf(\"%d\", &amp;amp;m); int u, v, w; for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d%d\", &amp;amp;u, &amp;amp;v, &amp;amp;w); qw[i] = w; query[u].push_back(Pair(v, i)); query[v].push_back(Pair(u, i)); &#125; tarjan(); for (int i = 1; i &amp;lt;= m; i++) &#123; LL tmp = sum - lca[i] + qw[i]; printf(LLS\"\\n\", min(tmp, sum)); &#125; &#125;&#125;"},{"title":"POJ1989 Distance Queries","permalink":"http://sfork.coding.me/2014/08/01/poj1989-distance-queries/","text":"##Description Farmer John’s cows refused to run in his marathon since he chose a path much too long for their leisurely lifestyle. He therefore wants to find a path of a more reasonable length. The input to this problem consists of the same input as in “Navigation Nightmare”,followed by a line containing a single integer K, followed by K “distance queries”. Each distance query is a line of input containing two integers, giving the numbers of two farms between which FJ is interested in computing distance (measured in the length of the roads along the path between the two farms). Please answer FJ’s distance queries as quickly as possible! ##Input Lines 1..1+M: Same format as “Navigation Nightmare” Line 2+M: A single integer, K. 1 &lt;= K &lt;= 10,000 Lines 3+M..2+M+K: Each line corresponds to a distance query and contains the indices of two farms. ##Output Lines 1..K: For each distance query, output on a single line an integer giving the appropriate distance. ##Sample Input 7 61 6 13 E6 3 9 E3 5 7 S4 1 3 N2 4 20 W4 7 2 S31 61 42 6 ##Sample Output13336 ##HintFarms 2 and 6 are 20+3+13=36 apart. ##SourceUSACO 2004 February 无向树求节点距离：dist(u,v)=dist(root,u)+dist(root,v)-2*dist(root,lca(u,v)) tarjan+并查集求LCA。注意可能树不连通。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define MP make_pair#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SI(x) set&amp;lt;x&amp;gt;::iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;#define N 40005#define M 40005int n, m;//Edge Graphint head[N], pos;struct Edge &#123; int v, w, nxt;&#125; e[M &amp;lt;&amp;lt; 1];void initEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v, int w) &#123; e[pos].v = v; e[pos].w = w; e[pos].nxt = head[u]; head[u] = pos++;&#125;//UnionSetint p[N];void initUset() &#123; for (int i = 0; i &amp;lt;= n; i++) p[i] = i;&#125;int uFind(int x) &#123; return x == p[x] ? p[x] : p[x] = uFind(p[x]);&#125;void uMerge(int x, int y) &#123; //y合并到x int fx = uFind(x); int fy = uFind(y); if (fx != fy) p[fy] = fx;&#125;//tarjan-LCAint size,bcnt;int lca[10005];int vis[N];int dis[N];int ans[10005];vector&amp;lt;pr&amp;lt;int, int&amp;gt; &amp;gt; query[N];int findRoot() &#123; for (int i = 1; i &amp;lt;= n; i++) &#123; if (!vis[i]) return i; &#125; return assert(false),-1;&#125;int dfs(int u, int fa) &#123; int solved = 0; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; if (v == fa) continue; dis[v] = dis[u] + e[i].w; solved += dfs(v, u); if (solved == size) return solved; uMerge(u, v); &#125; vis[u] = bcnt; for (int i = 0; i &amp;lt; (int) query[u].size(); i++) &#123; int v = query[u][i].F; if (vis[v]==bcnt) &#123; solved++; lca[query[u][i].S] = uFind(v); ans[query[u][i].S] = dis[u] + dis[v] - 2 * dis[lca[query[u][i].S]]; &#125; &#125; return solved;&#125;void tarjan() &#123; clrA(vis, 0); clrA(dis, 0); int tot = 0; bcnt=0; do &#123; bcnt++;//从1开始 tot += dfs(findRoot(), -1); &#125; while (tot &amp;lt; size);//图可能不连通&#125;int main() &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;m)) &#123; int u, v, w; char c; initEdge(); for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d%d %c\", &amp;amp;u, &amp;amp;v, &amp;amp;w, &amp;amp;c); add(u, v, w); add(v, u, w); &#125; initUset(); scanf(\"%d\", &amp;amp;size); for (int i = 1; i &amp;lt;= n; i++) query[i].clear(); for (int i = 1; i &amp;lt;= size; i++) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); query[u].push_back(MP(v, i)); query[v].push_back(MP(u, i)); &#125; tarjan(); for (int i = 1; i &amp;lt;= size; i++) &#123; printf(\"%d\\n\", ans[i]); &#125; &#125;&#125; 另外，还可以转化为RMQ问题求解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;#define N 40005#define M 40005int n, m;//Edge Graphint head[N], pos;struct Edge &#123; int v, w, nxt;&#125; e[M &amp;lt;&amp;lt; 1];void initEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v, int w) &#123; e[pos].v = v; e[pos].w = w; e[pos].nxt = head[u]; head[u] = pos++;&#125;//RMQint dpM[20][N&amp;lt;&amp;lt;1|1];//dpM[i][j] 从j开始的，连续2^i个数字的最值,j从1开始int lg2[N&amp;lt;&amp;lt;1|1];//等价于 (int)lg2(1.0*m)/lg2(2.0) 若空间不足可以这样写#define getLeft(R,L) (R-(L)+1) //输入右端点和长度，返回左端点void initRMQ(int n) &#123; lg2[0]=-1;int limit; for(int i=1;i&amp;lt;=n;i++) &#123; lg2[i]=(i&amp;amp;(i-1))?lg2[i-1]:lg2[i-1]+1; &#125; for(int i=1;i&amp;lt;=lg2[n];i++)&#123; limit=getLeft(n,1&amp;lt;&amp;lt;i); for(int j=1;j&amp;lt;=limit;j++)&#123; dpM[i][j]=min(dpM[i-1][j],dpM[i-1][j+(1&amp;lt;&amp;lt;i&amp;gt;&amp;gt;1)]); &#125; &#125;&#125;int getRMQ(int a,int b) &#123; int t=lg2[b-a+1]; int s1=a; int s2=getLeft(b,1&amp;lt;&amp;lt;t); //return max(Max[t][s1],Max[t][s2]); return min(dpM[t][s1],dpM[t][s2]);&#125;#undef getLeft//LCAint dist[N];int H[N];//节点第一次出现的位置int E[N&amp;lt;&amp;lt;1|1];//欧拉序列2n+1个int cnt,depth;int findRoot()&#123; for(int i=1;i&amp;lt;=n;i++)return i; return -1;&#125;void getEuler(int u=findRoot(),int fa=-1)&#123; int tmp=dpM[0][H[u]=++cnt]=++depth; E[tmp]=u; for(int i=head[u];~i;i=e[i].nxt)&#123; int v=e[i].v; if(v==fa)continue; dist[v]=dist[u]+e[i].w; getEuler(v,u); dpM[0][++cnt]=tmp; &#125;&#125;void initLCA()&#123; memset(dist,0,sizeof(dist)); cnt=depth=0; getEuler(); initRMQ(cnt);&#125;int getLCA(int u,int v)&#123; if(H[u]&amp;gt;H[v])swap(u,v); return E[getRMQ(H[u],H[v])];&#125;int main() &#123; while (~scanf(\"%d%d\", &amp;amp;n, &amp;amp;m)) &#123; int u, v, w; char c; initEdge(); for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d%d %c\", &amp;amp;u, &amp;amp;v, &amp;amp;w, &amp;amp;c); add(u, v, w); add(v, u, w); &#125; initLCA(); scanf(\"%d\",&amp;amp;m); while(m--)&#123; scanf(\"%d%d\",&amp;amp;u,&amp;amp;v); printf(\"%d\\n\",dist[u]+dist[v]-2*dist[getLCA(u,v)]); &#125; &#125;&#125;"},{"title":"POJ1330 Nearest Common Ancestors","permalink":"http://sfork.coding.me/2014/08/01/poj1330-nearest-common-ancestors/","text":"Time Limit: 1000MS Memory Limit: 10000KTotal Submissions: 17734 Accepted: 9405 ##DescriptionA rooted tree is a well-known data structure in computer science and engineering. An example is shown below: In the figure, each node is labeled with an integer from {1, 2,…,16}. Node 8 is the root of the tree. Node x is an ancestor of node y if node x is in the path between the root and node y. For example, node 4 is an ancestor of node 16. Node 10 is also an ancestor of node 16. As a matter of fact, nodes 8, 4, 10, and 16 are the ancestors of node 16. Remember that a node is an ancestor of itself. Nodes 8, 4, 6, and 7 are the ancestors of node 7. A node x is called a common ancestor of two different nodes y and z if node x is an ancestor of node y and an ancestor of node z. Thus, nodes 8 and 4 are the common ancestors of nodes 16 and 7. A node x is called the nearest common ancestor of nodes y and z if x is a common ancestor of y and z and nearest to y and z among their common ancestors. Hence, the nearest common ancestor of nodes 16 and 7 is node 4. Node 4 is nearer to nodes 16 and 7 than node 8 is.For other examples, the nearest common ancestor of nodes 2 and 3 is node 10, the nearest common ancestor of nodes 6 and 13 is node 8, and the nearest common ancestor of nodes 4 and 12 is node 4. In the last example, if y is an ancestor of z, then the nearest common ancestor of y and z is y. Write a program that finds the nearest common ancestor of two distinct nodes in a tree. ##InputThe input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case starts with a line containing an integer N , the number of nodes in a tree, 2&lt;=N&lt;=10,000. The nodes are labeled with integers 1, 2,…, N. Each of the next N -1 lines contains a pair of integers that represent an edge –the first integer is the parent node of the second integer. Note that a tree with N nodes has exactly N - 1 edges. The last line of each test case contains two distinct integers whose nearest common ancestor is to be computed. ##OutputPrint exactly one line for each test case. The line should contain the integer that is the nearest common ancestor. ##Sample Input 2161 148 510 165 94 68 44 101 136 1510 116 710 216 38 116 1216 752 33 43 11 53 5 ##Sample Output 43 ##SourceTaejon 2002 tarjan+并查集求LCA模板。将u的子儿子v递归合并到u，若y在x的子树上，则根据并查集的性质，公共祖先即为x（father[y]）。若y和x不再同一子树上。则根据dfs回溯的性质，则搜完y之后一定是回溯到x,y的最近公共祖先才能搜到x的，而此时由并查集的性质，回溯的节点刚好就是father[y]。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define MP make_pair#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SI(x) set&amp;lt;x&amp;gt;::iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf=~0u&amp;gt;&amp;gt;1;const LL lnf=~0ull&amp;gt;&amp;gt;1;#define N 10005#define M 10005int n, m;//UnionSetint p[N];void initUset() &#123; for (int i = 0; i &amp;lt;= n; i++) p[i] = i;&#125;int uFind(int x) &#123; return x == p[x] ? p[x] : p[x] = uFind(p[x]);&#125;void uMerge(int x, int y) &#123; //y合并到x int fx = uFind(x); int fy = uFind(y); if (fx != fy) p[fy]=fx;&#125;//Edge Graphint head[N], pos;struct Edge &#123; int v, nxt;&#125; e[M];void initEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v) &#123; e[pos].v = v; e[pos].nxt = head[u]; head[u] = pos++;&#125;int findRoot()&#123;//有向图选择入度为0的点，无向图不同节点做根，LCA结果将不同。 for (int i = 1; i &amp;lt; n; i++) if (indeg[i] == 0) return i; return assert(false),-1;&#125;//LCAint size, root;int vis[N];int ans[5];int indeg[N];vector&amp;lt;pr&amp;lt;int, int&amp;gt; &amp;gt; que[N];int dfs(int u) &#123; int solved=0; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; solved+=dfs(v); if(solved==size)return solved; uMerge(u, v); &#125; vis[u] = 1; for (int i = 0; i &amp;lt; (int) que[u].size(); i++) &#123; int v = que[u][i].F; if (vis[v]) &#123; ans[que[u][i].S] = uFind(v); solved++; &#125; &#125; return solved;&#125;void tarjan() &#123; clrA(vis,0); dfs(findRoot());&#125;int main() &#123; int T; scanf(\"%d\", &amp;amp;T); while (T--) &#123; scanf(\"%d\", &amp;amp;n); initEdge(); int u, v; clrA(indeg,0); for (int i = 1; i &amp;lt; n; i++) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); add(u, v); indeg[v]++; &#125; initUset(); size = 1;//查询的次数 for(int i=1;i&amp;lt;=n;i++)que[i].clear(); for (int i = 1; i &amp;lt;= size; i++) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); que[u].push_back(MP(v, i)); que[v].push_back(MP(u, i)); &#125; tarjan(); for (int i = 1; i &amp;lt;= size; i++) &#123; printf(\"%d\\n\", ans[i]); &#125; &#125;&#125; LCA还可以用倍增来求：（思想很普通，只是以2进制的步长向上走：dp[i][j]表示节点i向上走2^j步到达的节点。）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define qlr(x) while(!x.empty)x.pop();#define clr(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;#define N 10005#define M N-1int n;int head[N], pos;struct edge &#123; int v, nxt;&#125; e[M];void add(int u, int v) &#123; e[pos].v = v; e[pos].nxt = head[u]; head[u] = pos++;&#125;void initEdge() &#123; clr(head, -1); pos = 0;&#125;int deep[N];vector&amp;lt;int&amp;gt; dp[N];int size;int findRoot() &#123; for (int i = 1; i &amp;lt;= n; i++) &#123; if (dp[i].empty()) return i; &#125; return -1;&#125;void getDeep(int u = findRoot()) &#123; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; deep[v] = deep[u] + 1; getDeep(v); &#125; size = max(size, deep[u] + 1);//记录最大深度&#125;void initLCA() &#123; clr(deep, 0); size = 0; getDeep(); for (int len = 1,t=2;t&amp;lt;=size; len++,t&amp;lt;&amp;lt;=1) &#123;//跳出条件：(t=2^len)&amp;lt;=size for (int i = 1; i &amp;lt;= n; i++) &#123; if ((int)dp[i].size() &amp;gt;= len &amp;amp;&amp;amp; (int)dp[dp[i][len-1]].size() &amp;gt;= len) &#123; dp[i].push_back(dp[dp[i][len-1]][len-1]); &#125; &#125; &#125;&#125;int getLCA(int u, int v) &#123; if (deep[u] &amp;lt; deep[v]) swap(u, v); int d = deep[u] - deep[v]; for (int i = 0; d; i++, d &amp;gt;&amp;gt;= 1) &#123; u = d &amp;amp; 1 ? dp[u][i] : u; &#125;//以差值二进制形式将u往上走差值 if (u == v) return u; for (int i = min(dp[u].size(),dp[v].size())-1; i &amp;gt;= 0; i--) &#123; if (dp[u][i] != dp[v][i]) &#123; u = dp[u][i]; v = dp[v][i]; i=(int)min(dp[u].size(),dp[v].size());//注意每次都要更新i！！ &#125; &#125; u = dp[u][0]; return u;&#125;int main() &#123; int T; cin &amp;gt;&amp;gt; T; while (T--) &#123; scanf(\"%d\", &amp;amp;n); int u, v; initEdge(); for (int i = 1; i &amp;lt;= n; i++) dp[i].clear(); for (int i = 1; i &amp;lt; n; i++) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); add(u, v); dp[v].push_back(u); &#125; initLCA(); scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); printf(\"%d\\n\", getLCA(u, v)); &#125;&#125; LCA还可以转化为RMQ问题（个人更喜欢此方法，在线，且效率高）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//============================================================================// Name : test3.cpp// Author : // Version :// Copyright : Your copyright notice// Description : Hello World in C++, Ansi-style//============================================================================#include&amp;lt;map&amp;gt;#include&amp;lt;set&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;cctype&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;utility&amp;gt;#include&amp;lt;numeric&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;#define pr pair#define MP make_pair#define SI(x) set&amp;lt;x&amp;gt;::iterator#define VI(x) vector&amp;lt;x&amp;gt;::iterator#define MI(x,y) map&amp;lt;x,y&amp;gt;::iterator#define SRI(x) set&amp;lt;x&amp;gt;::reverse_iterator#define VRI(x) vector&amp;lt;x&amp;gt;::reverse_iterator#define MRI(x,y) map&amp;lt;x,y&amp;gt;::reverse_iterator#define F first#define S second#define clrQ(x) while(!x.empty)x.pop();#define clrA(x,y) memset(x,y,sizeof(x));#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endifconst int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;int n, m;#define N 10005#define M 10005int head[N], pos;struct Edge &#123; int v, nxt;&#125; e[M];void initEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v) &#123; e[pos].v = v; e[pos].nxt = head[u]; head[u] = pos++;&#125;//RMQint dpM[20][N &amp;lt;&amp;lt; 1 | 1];int lg2[N &amp;lt;&amp;lt; 1 | 1];#define getLeft(R,L) (R-(L)+1)void initRMQ(int n) &#123; //dp[0][i]表示区间i的值。预先处理出来。 lg2[0] = -1; int limit; for (int i = 1; i &amp;lt;= n; i++) &#123; lg2[i] = i &amp;amp; (i - 1) ? lg2[i - 1] : lg2[i - 1] + 1; &#125; for (int i = 1; i &amp;lt;= lg2[n]; i++) &#123; limit = getLeft(n, 1 &amp;lt;&amp;lt; i); for (int j = 1; j &amp;lt;= limit; j++) &#123; dpM[i][j] = min(dpM[i - 1][j], dpM[i - 1][j + (1 &amp;lt;&amp;lt; (i - 1))]); &#125; &#125;&#125;int getRMQ(int x, int y) &#123; if (x &amp;gt; y) swap(x, y); int t = lg2[y - x + 1]; return min(dpM[t][x], dpM[t][getLeft(y, 1 &amp;lt;&amp;lt; t)]);&#125;//LCAint depth, cnt;int inde[N], H[N], E[N];//dp[0][N&amp;lt;&amp;lt;1|1]深度序列（dfs编号），E[N]每个dfs编号对应的节点，H[N]节点第一次出现在dfs编号序列中的位置int findRoot() &#123; for (int i = 1; i &amp;lt;= n; i++) if (!inde[i]) return i; return -1;&#125;void getEuler(int u = findRoot()) &#123; int dfn = dpM[0][H[u] = ++cnt] = ++depth; E[dfn] = u; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; getEuler(v); dpM[0][++cnt] = dfn; &#125;&#125;void initLCA() &#123; depth = cnt = 0; getEuler(); initRMQ(cnt);&#125;int getLCA(int u, int v) &#123; if (H[u] &amp;gt; H[v]) swap(u, v); return E[getRMQ(H[u], H[v])];&#125;int main() &#123; int T; scanf(\"%d\", &amp;amp;T); while (T--) &#123; scanf(\"%d\", &amp;amp;n);m=n-1; int u, v; initEdge(); memset(inde, 0, sizeof(inde)); for (int i = 1; i &amp;lt;= m; i++) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); add(u, v); inde[v]++; &#125; initLCA(); scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); printf(\"%d\\n\", getLCA(u, v)); &#125;&#125; &nbsp;"},{"title":"2014 Multi-University Training Contest 4","permalink":"http://sfork.coding.me/2014/07/31/2014-multi-university-training-contest-4/","text":"心情就像倒数第二楼那样。 CLJ，我也保证不打死你…… PS:最后一楼朱大神还暴露了。"},{"title":"HDU4005 The war","permalink":"http://sfork.coding.me/2014/07/30/hdu4005-the-war/","text":"Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65768/65768 K (Java/Others)Total Submission(s): 1992 Accepted Submission(s): 440 Problem DescriptionIn the war, the intelligence about the enemy is very important. Now, our troop has mastered the situation of the enemy’s war zones, and known that these war zones can communicate to each other directly or indirectly through the network. We also know the enemy is going to build a new communication line to strengthen their communication network. Our task is to destroy their communication network, so that some of their war zones can’t communicate. Each line has its “cost of destroy”. If we want to destroy a line, we must spend the “cost of destroy” of this line. We want to finish this task using the least cost, but our enemy is very clever. Now, we know the network they have already built, but we know nothing about the new line which our enemy is going to build. In this condition, your task is to find the minimum cost that no matter where our enemy builds the new line, you can destroy it using the fixed money. Please give the minimum cost. For efficiency, we can only destroy one communication line.&nbsp;InputThe input contains several cases. For each cases, the first line contains two positive integers n, m (1&lt;=n&lt;=10000, 0&lt;=m&lt;=100000) standing for the number of the enemy’s war zones (numbered from 1 to n), and the number of lines that our enemy has already build. Then m lines follow. For each line there are three positive integer a, b, c (1&lt;=a, b&lt;=n, 1&lt;=c&lt;=100000), meaning between war zone A and war zone B there is a communication line with the “cost of destroy “ c.&nbsp;OutputFor each case, if the task can be finished output the minimum cost, or output ‐1.&nbsp;Sample Input3 2 1 2 1 2 3 2 4 3 1 2 1 1 3 2 1 4 3&nbsp;Sample Output-1 3HintFor the second sample input: our enemy may build line 2 to 3, 2 to 4, 3 to 4. If they build line 2 to 3, we will destroy line 1 to 4, cost 3. If they build line 2 to 4, we will destroy line 1 to 3, cost 2. If they build line 3 to 4, we will destroy line 1 to 2, cost 1. So, if we want to make sure that we can destroy successfully, the minimum cost is 3.&nbsp;&nbsp;Source The 36th ACM/ICPC Asia Regional Dalian Site —— Online Contest 求无向图边双连通分量缩点，然后DP求第二长边。//#pragma comment(linker, “/STACK:1024000000,1024000000”)//C++加栈#include#include#include#include#include#include#include#include#include#include#includeusing namespace std;#if defined (_WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32)#define LL int64#define LLS “%” “I” “6” “4” “d”#define LLU “%” “I” “6” “4” “u”#define LL_MAX _I64_MAX#else#define LL long long#define LLS “%” “l” “l” “d”#define LLU “%” “l” “l” “u”#define LL_MAX _I64_MAX#endif#define N 10005#define M 100005int n, m;const int inf = ~0u &gt;&gt; 1;const LL lnf = ~0ull &gt;&gt; 1;struct edge { int v, w, nxt; bool mark;} e[M &lt;&lt; 1];struct bridge { int u, v, w; bridge(int u, int v, int w) { this-&gt;u = u; this-&gt;w = w; this-&gt;v = v; }};int pos, head[N];int top, stk[N];int pre[N], dfs_clock, belong[N], bcnt;vector brg;void InitEdge() { memset(head, -1, sizeof(head)); pos = 0;}void add(int u, int v, int w) { e[pos].v = v; e[pos].w = w; e[pos].nxt = head[u]; head[u] = pos++;}int dfs(int u,int fa) { int lowu = pre[u] = ++dfs_clock; stk[top++] = u; bool vis=true; for (int i = head[u]; ~i; i = e[i].nxt) { int v = e[i].v; if(v==fa &amp;&amp; vis){ vis=false;//重边 continue; } if (!pre[v]) { int lowv = dfs(v,u); lowu = min(lowu, lowv); if (lowv &gt; pre[u]) { //u-v为桥 brg.push_back(bridge(u, v, e[i].w)); } } else lowu = min(lowu, pre[v]); } if (pre[u] == lowu) { bcnt++; do { belong[stk[–top]] = bcnt; } while (stk[top] != u); } return lowu;}void tarjan() { top = bcnt = dfs_clock = 0; memset(pre, 0, sizeof(pre)); memset(belong, 0, sizeof(belong)); brg.clear(); for (int i = 1; i &lt;= n; i++) { if (!pre[i])dfs(i,-1); }}void rebuild() { //根据桥来缩点重构图 InitEdge(); for (int i = 0; i &lt; (int) brg.size(); i++) { int u = belong[brg[i].u]; int v = belong[brg[i].v]; int w = brg[i].w; add(u, v, w); add(v, u, w); }}int res;int DP(int u, int fa) { int Min = inf; for (int i = head[u]; ~i; i = e[i].nxt) { int v = e[i].v; if (v == fa)continue; int w = DP(v, u); w = min(w, e[i].w); if (Min &gt; w) { res = min(res, Min); Min = w; } else res = min(res, w); } return Min;}int main() { while (~scanf(“%d%d”, &amp;n, &amp;m)) { int u, v, w; InitEdge(); for (int i = 0; i &lt; m; i++) { scanf(“%d%d%d”, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); } tarjan(); rebuild(); bridge minbrg(-1, -1, inf); for (int i = 0; i &lt; (int) brg.size(); i++) { if (brg[i].w &lt; minbrg.w) { minbrg = brg[i]; } } res = inf; DP(belong[minbrg.u], belong[minbrg.v]); DP(belong[minbrg.v], belong[minbrg.u]); if(res==inf)res=-1; printf(“%d\\n”, res); }}"},{"title":"HDU4612 Warm up","permalink":"http://sfork.coding.me/2014/07/30/hdu4612-warm-up/","text":"Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 65535/65535 K (Java/Others)Total Submission(s): 3532 Accepted Submission(s): 813 Problem Description N planets are connected by M bidirectional channels that allow instant transportation. It’s always possible to travel between any two planets through these channels.If we can isolate some planets from others by breaking only one channel , the channel is called a bridge of the transportation system.People don’t like to be isolated. So they ask what’s the minimal number of bridges they can have if they decide to build a new channel.Note that there could be more than one channel between two planets. Input The input contains multiple cases.Each case starts with two positive integers N and M , indicating the number of planets and the number of channels.(2&lt;=N&lt;=200000, 1&lt;=M&lt;=1000000)Next M lines each contains two positive integers A and B, indicating a channel between planet A and B in the system. Planets are numbered by 1..N.A line with two integers ‘0’ terminates the input. Output For each case, output the minimal number of bridges after building a new channel in a line. Sample Input 4 4 1 2 1 3 1 4 2 3 0 0 Sample Output 0 Source 2013 Multi-University Training Contest 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#pragma comment(linker, \"/STACK:1024000000,1024000000\")//C++加栈#include#include#include#include#include#include#include#include&lt;map&gt;#include#include#includeusing namespace std;#if defined (_WIN32) || defined (__WIN32) || defined (WIN32) || defined (__WIN32__)#define LL __int64#define LLS \"%\" \"I\" \"6\" \"4\" \"d\"#define LLU \"%\" \"I\" \"6\" \"4\" \"u\"#define LL_MAX _I64_MAX#else#define LL long long#define LLS \"%\" \"l\" \"l\" \"d\"#define LLU \"%\" \"l\" \"l\" \"u\"#define LL_MAX _I64_MAX#endif#define N 200005#define M 1000005int n, m;const int inf = ~0u &amp;gt;&amp;gt; 1;const LL lnf = ~0ull &amp;gt;&amp;gt; 1;struct edge &#123; int v, nxt;&#125; e[M &amp;lt;&amp;lt; 1];struct bridge &#123; int u, v; bridge(int u, int v) &#123; this-&amp;gt;u = u; this-&amp;gt;v = v; &#125;&#125;;int pos, head[N];int top, stk[N];int pre[N], dfs_clock, belong[N], bcnt;vector brg;void InitEdge() &#123; memset(head, -1, sizeof(head)); pos = 0;&#125;void add(int u, int v) &#123; e[pos].v = v; e[pos].nxt = head[u]; head[u] = pos++;&#125;int dfs(int u, int fa) &#123; int lowu = pre[u] = ++dfs_clock; stk[top++] = u; bool vis = true; for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; if (v == fa &amp;amp;&amp;amp; vis) &#123; vis = false; //u-v的反向边一定是v-u邻接表里的第一条边。 continue; &#125; if (!pre[v]) &#123; int lowv = dfs(v, u); lowu = min(lowu, lowv); if (lowv &amp;gt; pre[u]) &#123; //u-v为桥 brg.push_back(bridge(u, v)); &#125; &#125; else lowu = min(lowu, pre[v]); &#125; if (pre[u] == lowu) &#123; bcnt++; do &#123; belong[stk[--top]] = bcnt; &#125; while (stk[top] != u); &#125; return lowu;&#125;void tarjan() &#123; top = bcnt = dfs_clock = 0; memset(pre, 0, sizeof(pre)); memset(belong, 0, sizeof(belong)); brg.clear(); for (int i = 1; i &amp;lt;= n; i++) &#123; if (!pre[i]) dfs(i, -1); &#125;&#125;void rebuild() &#123; //根据桥来缩点重构图 InitEdge(); for (int i = 0; i &amp;lt; (int) brg.size(); i++) &#123; int u = belong[brg[i].u]; int v = belong[brg[i].v]; add(u, v); add(v, u); &#125;&#125;int diameter = 0;int findR(int u, int fa) &#123; int h1 = 0, h2 = 0; // 以u为根，h1最高的儿子，h2次高儿子。放在dfs里面两者不会重合。 for (int i = head[u]; ~i; i = e[i].nxt) &#123; int v = e[i].v; if (v == fa) continue; int h = findR(v, u) + 1; //若路径有权重，则把1改为u-v的权重 if (h &amp;gt; h1) h2 = h1, h1 = h; else h2 = max(h, h2); &#125; diameter = max(diameter, h1 + h2); return h1;&#125;void tree_diameter() &#123; diameter = 0; findR(1, -1);&#125;int main() &#123; while (scanf(\"%d%d\", &amp;amp;n, &amp;amp;m), n || m) &#123; int u, v; InitEdge(); for (int i = 0; i &amp;lt; m; i++) &#123; scanf(\"%d%d\", &amp;amp;u, &amp;amp;v); add(u, v); add(v, u); &#125; tarjan(); rebuild(); tree_diameter(); printf(\"%d\\n\", bcnt - diameter - 1); &#125;&#125;"},{"title":"HDU4888 Redraw Beautiful Drawings ","permalink":"http://sfork.coding.me/2014/07/29/hdu4888-redraw-beautiful-drawings/","text":"Problem Description Alice and Bob are playing together. Alice is crazy about art and she has visited many museums around the world. She has a good memory and she can remember all drawings she has seen.Today Alice designs a game using these drawings in her memory. First, she matches K+1 colors appears in the picture to K+1 different integers(from 0 to K). After that, she slices the drawing into grids and there are N rows and M columns. Each grid has an integer on it(from 0 to K) representing the color on the corresponding position in the original drawing. Alice wants to share the wonderful drawings with Bob and she tells Bob the size of the drawing, the number of different colors, and the sum of integers on each row and each column. Bob has to redraw the drawing with Alice’s information. Unfortunately, somtimes, the information Alice offers is wrong because of Alice’s poor math. And sometimes, Bob can work out multiple different drawings using the information Alice provides. Bob gets confused and he needs your help. You have to tell Bob if Alice’s information is right and if her information is right you should also tell Bob whether he can get a unique drawing. &nbsp; Input The input contains mutiple testcases.For each testcase, the first line contains three integers N(1 ≤ N ≤ 400) , M(1 ≤ M ≤ 400) and K(1 ≤ K ≤ 40).N integers are given in the second line representing the sum of N rows.M integers are given in the third line representing the sum of M columns.The input is terminated by EOF. &nbsp; Output For each testcase, if there is no solution for Bob, output “Impossible” in one line(without the quotation mark); if there is only one solution for Bob, output “Unique” in one line(without the quotation mark) and output an N * M matrix in the following N lines representing Bob’s unique solution; if there are many ways for Bob to redraw the drawing, output “Not Unique” in one line(without the quotation mark). &nbsp; Sample Input 2 2 4 4 2 4 2 4 2 2 2 2 5 0 5 4 1 4 3 9 1 2 3 3 &nbsp; Sample Output Not Unique Impossible Unique 1 2 3 3&nbsp; 第一步，考虑如何求是否有解。使用网络流求解，每一行和每一列分别对应一个点，加上源点和汇点一共有N+M+2个点。有三类边： 源点 -&gt; 每一行对应的点，流量限制为该行的和 每一行对应的点 -&gt; 每一列对应的点，流量限制为 K 每一列对应的点 -&gt; 汇点，流量限制为该列的和&nbsp; 对上图做最大流，若源点出发的边和到达汇点的边全都满流，则有解，否则无解。若要求构造方案，则 (i,j) 对应的整数就是行 i–&gt; 列 j 的流量。 第二步，考虑解是否唯一。显然，解唯一的充分必要条件是完成最大流后的残余网络没有长度大于 2 的环。所以，判断解的唯一性可使用dfs，注意遍历的时候不可以在走完一条边后马上走其反向边，加此限制检查是否有环即可判断解是否唯一。 至此，全题已解决。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cstdlib&amp;gt;using namespace std;const int maxn=500,maxm=maxn*maxn;int next[maxm*2],num[maxm*2],r[maxm*2],a[maxn*2],row_sum[maxn],col_sum[maxn],n,m,K,tt,T,d[maxn*2],st[maxn*2],cod[maxn][maxn];int h[maxn*2],vh[maxn*2];bool don[maxm*2],in[maxn*2];void insert(int x,int y,int rr)&#123; next[++tt]=a[x];num[tt]=y;r[tt]=rr;a[x]=tt; next[++tt]=a[y];num[tt]=x;r[tt]=0;a[y]=tt;&#125;void construct()&#123; tt=1;T=n+m+1; for (int i=0;i&amp;lt;=T;i++) a[i]=0; for (int i=1;i&amp;lt;=n;i++) insert(0,i,row_sum[i]); for (int i=1;i&amp;lt;=m;i++) insert(i+n,T,col_sum[i]); for (int i=1;i&amp;lt;=n;i++) &#123; for (int j=1;j&amp;lt;=m;j++) &#123; insert(i,j+n,K); cod[i][j]=tt; &#125; &#125;&#125;int dfs(int x,int y)&#123; if (x==T) return y; int sig=st[x],minh=T+1; do &#123; if (r[st[x]]) &#123; if (h[num[st[x]]]+1==h[x]) &#123; int k=dfs(num[st[x]],min(y,r[st[x]])); if (k) &#123; r[st[x]]-=k; r[st[x]^1]+=k; return k; &#125; &#125; minh=min(minh,h[num[st[x]]]+1); if (h[0]&amp;gt;T) return 0; &#125; st[x]=next[st[x]]; if (st[x]==0) st[x]=a[x]; &#125;while (sig!=st[x]); if (vh[h[x]]--==0) h[0]=T+1; vh[h[x]=minh]++; return 0;&#125;int max_flow()&#123; for (int i=0;i&amp;lt;=T;i++) h[i]=vh[i]=0; for (int i=0;i&amp;lt;=T;i++) st[i]=a[i]; vh[0]=T+1; int ret=0; while (h[0]&amp;lt;=T) ret+=dfs(0,K+1); return ret;&#125;/*bool find_circle()&#123; deque q; for (int i=0;i&amp;lt;=T;i++) d[i]=0; for (int i=0;i&amp;lt;=T;i++) &#123; for (int p=a[i];p;p=next[p]) &#123; if (r[p]) d[i]++; &#125; if (d[i]==0) q.push_back(i); &#125; int cnt=T+1; while (!q.empty()) &#123; int x=q.front(); cnt--; q.pop_front(); for (int p=a[x];p;p=next[p]) &#123; if (r[p^1]) &#123; d[num[p]]--; if (d[num[p]]==0) q.push_back(num[p]); &#125; &#125; &#125; return cnt;&#125;*/bool visit(int x,int ed)&#123; if (don[ed]) return in[x]; don[ed]=true; in[x]=true; for (int p=a[x];p;p=next[p]) &#123; if (r[p] &amp;amp;&amp;amp; (ed^p)!=1) if (visit(num[p],p)) return true; &#125; in[x]=false; return false;&#125;bool find_circle()&#123; for (int i=0;i&amp;lt;=T;i++) in[i]=false; for (int i=1;i&amp;lt;=tt;i++) don[i]=false; int col=0; for (int i=2;i&amp;lt;=tt;i++) &#123; if (r[i] &amp;amp;&amp;amp; !don[i]) &#123; in[num[i^1]]=true; if (visit(num[i],i)) return true; in[num[i^1]]=false; &#125; &#125; return false;&#125;void print_scheme()&#123; printf(\"Unique\\n\"); for (int i=1;i&amp;lt;=n;i++) &#123; printf(\"%d\",r[cod[i][1]]); for (int j=2;j&amp;lt;=m;j++) printf(\" %d\",r[cod[i][j]]); printf(\"\\n\"); &#125;&#125;int main()&#123; while (scanf(\"%d%d%d\",&amp;amp;n,&amp;amp;m,&amp;amp;K)!=EOF) &#123; int tmp=0; for (int i=1;i&amp;lt;=n;i++) &#123; scanf(\"%d\",&amp;amp;row_sum[i]); tmp+=row_sum[i]; &#125; int sum=tmp; for (int i=1;i&amp;lt;=m;i++) &#123; scanf(\"%d\",&amp;amp;col_sum[i]); tmp-=col_sum[i]; &#125; if (tmp) &#123; printf(\"Impossible\\n\"); continue; &#125; construct(); if (max_flow()&amp;lt;sum) &#123; printf(\"Impossible\\n\"); continue; &#125; if (find_circle()) &#123; printf(\"Not Unique\\n\"); &#125;else print_scheme(); &#125; return 0;&#125;"}]}